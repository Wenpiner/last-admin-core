Name: core.rpc
ListenOn: 0.0.0.0:8080

DatabaseConf:
  Host: 127.0.0.1
  Port: 5432
  Username: postgres
  Password: "postgres"
  DatabaseName: last_admin
  SSLMode: disable
  DBType: postgres
  MaxOpenConns: 100
  MaxIdleConns: 10
  CacheTime: 300
  DBPath: ""

OAuthStateSecret: "7kR9mL2pQ5xW8vN3jB6cF1dE4sT0uY9aZ"

CasbinConf:
  ModelText: |
    [request_definition]
    # r = sub, dom, obj, act
    # r.sub: 主体 (用户)
    # r.dom: 域 (在这里就是您的“资源类型”，如 'api', 'configuration')
    # r.obj: 客体 (资源路径)
    # r.act: 动作 (HTTP方法 或 'read'/'write'/'view')
    r = sub, dom, obj, act

    [policy_definition]
    # p = sub, dom, obj, act
    # p.sub: 主体 (角色)
    # p.dom: 域 (资源类型)
    # p.obj: 客体 (资源路径)
    # p.act: 动作
    p = sub, dom, obj, act

    [role_definition]
    # g = _, _
    # 我们保持角色是全局的，不分域
    g = _, _

    [policy_effect]
    e = some(where (p.eft == allow))

    [matchers]
    # m = g(r.sub, p.sub) && r.dom == p.dom && keyMatch2(r.obj,p.obj) && (r.act == p.act || p.act == '*')
    # 核心改动：增加了 r.dom == p.dom
    # 1. 检查用户(r.sub)是否属于角色(p.sub)
    # 2. 检查请求的域(r.dom)是否与策略的域(p.dom)完全匹配
    # 3. 检查资源路径(r.obj)是否匹配 (继续使用 keyMatch2)
    # 4. 检查动作(r.act)是否匹配 (如果 p.act == '*' 则表示允许所有动作)
    m = g(r.sub, p.sub) && r.dom == p.dom && keyMatch2(r.obj, p.obj) && (r.act == p.act || p.act == '*')

# Redis配置
RedisConf:
  Host: "127.0.0.1:16379"
  Password: "redis123"
  DB: 0
  PoolSize: 10
