Name: core.rpc
ListenOn: 0.0.0.0:8080

DatabaseConf:
  Host: 127.0.0.1
  Port: 5432
  Username: postgres
  Password: "postgres"
  DatabaseName: last_admin
  SSLMode: disable
  DBType: postgres
  MaxOpenConns: 100
  MaxIdleConns: 10
  CacheTime: 300
  DBPath: ""

OAuthStateSecret: "7kR9mL2pQ5xW8vN3jB6cF1dE4sT0uY9aZ"

CasbinConf:
  ModelText: |
    # model.conf
    # 这是一个基于角色的访问控制 (RBAC) 模型，支持 API 路径的模糊匹配。

    [request_definition]
    # r = sub, obj, act
    # r.sub: 请求的主体，通常是用户ID或用户名。
    # r.obj: 请求的客体，通常是 API 路径。
    # r.act: 请求的操作，通常是 HTTP 方法 (GET, POST, PUT, DELETE)。
    r = sub, obj, act

    [policy_definition]
    # p = sub, obj, act
    # p.sub: 策略的主体，在这里代表一个“角色”。
    # p.obj: 策略的客体，代表一个 API 路径模式。
    # p.act: 策略的操作，代表允许的 HTTP 方法。
    p = sub, obj, act

    [role_definition]
    # g = _, _
    # 定义了分组或角色关系。
    # 格式通常是：g, user_or_role_A, role_B
    # 表示 user_or_role_A 拥有 role_B 的权限（user 属于 role，或 role_A 继承 role_B）。
    g = _, _

    [policy_effect]
    # e = some(where (p.eft == allow))
    # 策略生效器：只要有一个匹配的策略允许访问，就允许。
    # 这是最常见的“默认拒绝，显式允许”模型。
    # 如果需要拒绝策略，可以修改为：e = some(where (p.eft == allow)) && !some(where (p.eft == deny))
    e = some(where (p.eft == allow))

    [matchers]
    # m = g(r.sub, p.sub) && keyMatch2(r.obj,p.obj) && r.act == p.act
    # 匹配器：定义如何将请求 (r) 与策略 (p) 进行匹配。
    # 1. g(r.sub, p.sub): 检查请求中的主体 (r.sub，即用户) 是否属于策略中的主体 (p.sub，即角色)。
    #    Casbin 会自动处理 g 关系中的继承，例如如果 user_alice 属于 admin 角色，admin 角色属于 viewer 角色，
    #    那么 g(user_alice, viewer) 也会返回 true。
    # 2. keyMatch2(r.obj, p.obj): 使用 keyMatch2 函数进行 API 路径匹配。
    #    支持通配符 '*' (匹配零个或多个字符) 和 '{param}' (匹配一个路径段并捕获)。
    #    例如：p.obj 可以是 "/api/v1/users/*" 或 "/api/v1/products/{id}"。
    # 3. r.act == p.act: 请求的操作 (HTTP 方法) 必须与策略的操作精确匹配。
    m = g(r.sub, p.sub) && keyMatch2(r.obj,p.obj) && r.act == p.act

# Redis配置
RedisConf:
  Host: "127.0.0.1:16379"
  Password: "redis123"
  DB: 0
  PoolSize: 10
