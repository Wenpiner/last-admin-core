// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/wenpiner/last-admin-core/rpc/ent/api"
	"github.com/wenpiner/last-admin-core/rpc/ent/configuration"
	"github.com/wenpiner/last-admin-core/rpc/ent/department"
	"github.com/wenpiner/last-admin-core/rpc/ent/dictitem"
	"github.com/wenpiner/last-admin-core/rpc/ent/dicttype"
	"github.com/wenpiner/last-admin-core/rpc/ent/menu"
	"github.com/wenpiner/last-admin-core/rpc/ent/oauthprovider"
	"github.com/wenpiner/last-admin-core/rpc/ent/operationlog"
	"github.com/wenpiner/last-admin-core/rpc/ent/position"
	"github.com/wenpiner/last-admin-core/rpc/ent/predicate"
	"github.com/wenpiner/last-admin-core/rpc/ent/role"
	"github.com/wenpiner/last-admin-core/rpc/ent/token"
	"github.com/wenpiner/last-admin-core/rpc/ent/user"
	"github.com/wenpiner/last-admin-core/rpc/ent/usertotp"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPI           = "API"
	TypeConfiguration = "Configuration"
	TypeDepartment    = "Department"
	TypeDictItem      = "DictItem"
	TypeDictType      = "DictType"
	TypeMenu          = "Menu"
	TypeOauthProvider = "OauthProvider"
	TypeOperationLog  = "OperationLog"
	TypePosition      = "Position"
	TypeRole          = "Role"
	TypeToken         = "Token"
	TypeUser          = "User"
	TypeUserTotp      = "UserTotp"
)

// APIMutation represents an operation that mutates the API nodes in the graph.
type APIMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	method        *string
	_path         *string
	description   *string
	is_required   *bool
	service_name  *string
	api_group     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*API, error)
	predicates    []predicate.API
}

var _ ent.Mutation = (*APIMutation)(nil)

// apiOption allows management of the mutation configuration using functional options.
type apiOption func(*APIMutation)

// newAPIMutation creates new mutation for the API entity.
func newAPIMutation(c config, op Op, opts ...apiOption) *APIMutation {
	m := &APIMutation{
		config:        c,
		op:            op,
		typ:           TypeAPI,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIID sets the ID field of the mutation.
func withAPIID(id uint32) apiOption {
	return func(m *APIMutation) {
		var (
			err   error
			once  sync.Once
			value *API
		)
		m.oldValue = func(ctx context.Context) (*API, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().API.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPI sets the old API of the mutation.
func withAPI(node *API) apiOption {
	return func(m *APIMutation) {
		m.oldValue = func(context.Context) (*API, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of API entities.
func (m *APIMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().API.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *APIMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *APIMutation) ClearName() {
	m.name = nil
	m.clearedFields[api.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *APIMutation) NameCleared() bool {
	_, ok := m.clearedFields[api.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *APIMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, api.FieldName)
}

// SetMethod sets the "method" field.
func (m *APIMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *APIMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *APIMutation) ResetMethod() {
	m.method = nil
}

// SetPath sets the "path" field.
func (m *APIMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *APIMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *APIMutation) ResetPath() {
	m._path = nil
}

// SetDescription sets the "description" field.
func (m *APIMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *APIMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *APIMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[api.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *APIMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[api.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *APIMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, api.FieldDescription)
}

// SetIsRequired sets the "is_required" field.
func (m *APIMutation) SetIsRequired(b bool) {
	m.is_required = &b
}

// IsRequired returns the value of the "is_required" field in the mutation.
func (m *APIMutation) IsRequired() (r bool, exists bool) {
	v := m.is_required
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequired returns the old "is_required" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldIsRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequired: %w", err)
	}
	return oldValue.IsRequired, nil
}

// ResetIsRequired resets all changes to the "is_required" field.
func (m *APIMutation) ResetIsRequired() {
	m.is_required = nil
}

// SetServiceName sets the "service_name" field.
func (m *APIMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *APIMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *APIMutation) ResetServiceName() {
	m.service_name = nil
}

// SetAPIGroup sets the "api_group" field.
func (m *APIMutation) SetAPIGroup(s string) {
	m.api_group = &s
}

// APIGroup returns the value of the "api_group" field in the mutation.
func (m *APIMutation) APIGroup() (r string, exists bool) {
	v := m.api_group
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIGroup returns the old "api_group" field's value of the API entity.
// If the API object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIMutation) OldAPIGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIGroup: %w", err)
	}
	return oldValue.APIGroup, nil
}

// ResetAPIGroup resets all changes to the "api_group" field.
func (m *APIMutation) ResetAPIGroup() {
	m.api_group = nil
}

// Where appends a list predicates to the APIMutation builder.
func (m *APIMutation) Where(ps ...predicate.API) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.API, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (API).
func (m *APIMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, api.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, api.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, api.FieldName)
	}
	if m.method != nil {
		fields = append(fields, api.FieldMethod)
	}
	if m._path != nil {
		fields = append(fields, api.FieldPath)
	}
	if m.description != nil {
		fields = append(fields, api.FieldDescription)
	}
	if m.is_required != nil {
		fields = append(fields, api.FieldIsRequired)
	}
	if m.service_name != nil {
		fields = append(fields, api.FieldServiceName)
	}
	if m.api_group != nil {
		fields = append(fields, api.FieldAPIGroup)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case api.FieldCreatedAt:
		return m.CreatedAt()
	case api.FieldUpdatedAt:
		return m.UpdatedAt()
	case api.FieldName:
		return m.Name()
	case api.FieldMethod:
		return m.Method()
	case api.FieldPath:
		return m.Path()
	case api.FieldDescription:
		return m.Description()
	case api.FieldIsRequired:
		return m.IsRequired()
	case api.FieldServiceName:
		return m.ServiceName()
	case api.FieldAPIGroup:
		return m.APIGroup()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case api.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case api.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case api.FieldName:
		return m.OldName(ctx)
	case api.FieldMethod:
		return m.OldMethod(ctx)
	case api.FieldPath:
		return m.OldPath(ctx)
	case api.FieldDescription:
		return m.OldDescription(ctx)
	case api.FieldIsRequired:
		return m.OldIsRequired(ctx)
	case api.FieldServiceName:
		return m.OldServiceName(ctx)
	case api.FieldAPIGroup:
		return m.OldAPIGroup(ctx)
	}
	return nil, fmt.Errorf("unknown API field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) SetField(name string, value ent.Value) error {
	switch name {
	case api.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case api.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case api.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case api.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case api.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case api.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case api.FieldIsRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequired(v)
		return nil
	case api.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case api.FieldAPIGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIGroup(v)
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown API numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(api.FieldName) {
		fields = append(fields, api.FieldName)
	}
	if m.FieldCleared(api.FieldDescription) {
		fields = append(fields, api.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIMutation) ClearField(name string) error {
	switch name {
	case api.FieldName:
		m.ClearName()
		return nil
	case api.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown API nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIMutation) ResetField(name string) error {
	switch name {
	case api.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case api.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case api.FieldName:
		m.ResetName()
		return nil
	case api.FieldMethod:
		m.ResetMethod()
		return nil
	case api.FieldPath:
		m.ResetPath()
		return nil
	case api.FieldDescription:
		m.ResetDescription()
		return nil
	case api.FieldIsRequired:
		m.ResetIsRequired()
		return nil
	case api.FieldServiceName:
		m.ResetServiceName()
		return nil
	case api.FieldAPIGroup:
		m.ResetAPIGroup()
		return nil
	}
	return fmt.Errorf("unknown API field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown API unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown API edge %s", name)
}

// ConfigurationMutation represents an operation that mutates the Configuration nodes in the graph.
type ConfigurationMutation struct {
	config
	op            Op
	typ           string
	id            *int
	sort          *int32
	addsort       *int32
	state         *bool
	name          *string
	group         *string
	key           *string
	value         *string
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Configuration, error)
	predicates    []predicate.Configuration
}

var _ ent.Mutation = (*ConfigurationMutation)(nil)

// configurationOption allows management of the mutation configuration using functional options.
type configurationOption func(*ConfigurationMutation)

// newConfigurationMutation creates new mutation for the Configuration entity.
func newConfigurationMutation(c config, op Op, opts ...configurationOption) *ConfigurationMutation {
	m := &ConfigurationMutation{
		config:        c,
		op:            op,
		typ:           TypeConfiguration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigurationID sets the ID field of the mutation.
func withConfigurationID(id int) configurationOption {
	return func(m *ConfigurationMutation) {
		var (
			err   error
			once  sync.Once
			value *Configuration
		)
		m.oldValue = func(ctx context.Context) (*Configuration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Configuration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfiguration sets the old Configuration of the mutation.
func withConfiguration(node *Configuration) configurationOption {
	return func(m *ConfigurationMutation) {
		m.oldValue = func(context.Context) (*Configuration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Configuration entities.
func (m *ConfigurationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigurationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigurationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Configuration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSort sets the "sort" field.
func (m *ConfigurationMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ConfigurationMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *ConfigurationMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ConfigurationMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ConfigurationMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetState sets the "state" field.
func (m *ConfigurationMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *ConfigurationMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *ConfigurationMutation) ClearState() {
	m.state = nil
	m.clearedFields[configuration.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *ConfigurationMutation) StateCleared() bool {
	_, ok := m.clearedFields[configuration.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *ConfigurationMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, configuration.FieldState)
}

// SetName sets the "name" field.
func (m *ConfigurationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConfigurationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConfigurationMutation) ResetName() {
	m.name = nil
}

// SetGroup sets the "group" field.
func (m *ConfigurationMutation) SetGroup(s string) {
	m.group = &s
}

// Group returns the value of the "group" field in the mutation.
func (m *ConfigurationMutation) Group() (r string, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroup returns the old "group" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroup: %w", err)
	}
	return oldValue.Group, nil
}

// ResetGroup resets all changes to the "group" field.
func (m *ConfigurationMutation) ResetGroup() {
	m.group = nil
}

// SetKey sets the "key" field.
func (m *ConfigurationMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ConfigurationMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ConfigurationMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *ConfigurationMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *ConfigurationMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *ConfigurationMutation) ResetValue() {
	m.value = nil
}

// SetDescription sets the "description" field.
func (m *ConfigurationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConfigurationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Configuration entity.
// If the Configuration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigurationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConfigurationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[configuration.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConfigurationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[configuration.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConfigurationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, configuration.FieldDescription)
}

// Where appends a list predicates to the ConfigurationMutation builder.
func (m *ConfigurationMutation) Where(ps ...predicate.Configuration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConfigurationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConfigurationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Configuration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConfigurationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConfigurationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Configuration).
func (m *ConfigurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigurationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.sort != nil {
		fields = append(fields, configuration.FieldSort)
	}
	if m.state != nil {
		fields = append(fields, configuration.FieldState)
	}
	if m.name != nil {
		fields = append(fields, configuration.FieldName)
	}
	if m.group != nil {
		fields = append(fields, configuration.FieldGroup)
	}
	if m.key != nil {
		fields = append(fields, configuration.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, configuration.FieldValue)
	}
	if m.description != nil {
		fields = append(fields, configuration.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigurationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configuration.FieldSort:
		return m.Sort()
	case configuration.FieldState:
		return m.State()
	case configuration.FieldName:
		return m.Name()
	case configuration.FieldGroup:
		return m.Group()
	case configuration.FieldKey:
		return m.Key()
	case configuration.FieldValue:
		return m.Value()
	case configuration.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configuration.FieldSort:
		return m.OldSort(ctx)
	case configuration.FieldState:
		return m.OldState(ctx)
	case configuration.FieldName:
		return m.OldName(ctx)
	case configuration.FieldGroup:
		return m.OldGroup(ctx)
	case configuration.FieldKey:
		return m.OldKey(ctx)
	case configuration.FieldValue:
		return m.OldValue(ctx)
	case configuration.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Configuration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configuration.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case configuration.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case configuration.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case configuration.FieldGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroup(v)
		return nil
	case configuration.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case configuration.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case configuration.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Configuration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigurationMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, configuration.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigurationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configuration.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigurationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configuration.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Configuration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigurationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configuration.FieldState) {
		fields = append(fields, configuration.FieldState)
	}
	if m.FieldCleared(configuration.FieldDescription) {
		fields = append(fields, configuration.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigurationMutation) ClearField(name string) error {
	switch name {
	case configuration.FieldState:
		m.ClearState()
		return nil
	case configuration.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Configuration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigurationMutation) ResetField(name string) error {
	switch name {
	case configuration.FieldSort:
		m.ResetSort()
		return nil
	case configuration.FieldState:
		m.ResetState()
		return nil
	case configuration.FieldName:
		m.ResetName()
		return nil
	case configuration.FieldGroup:
		m.ResetGroup()
		return nil
	case configuration.FieldKey:
		m.ResetKey()
		return nil
	case configuration.FieldValue:
		m.ResetValue()
		return nil
	case configuration.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Configuration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigurationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigurationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigurationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigurationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Configuration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigurationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Configuration edge %s", name)
}

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	state           *bool
	sort            *int32
	addsort         *int32
	dept_name       *string
	dept_code       *string
	description     *string
	clearedFields   map[string]struct{}
	parent          *uint32
	clearedparent   bool
	children        map[uint32]struct{}
	removedchildren map[uint32]struct{}
	clearedchildren bool
	users           map[uuid.UUID]struct{}
	removedusers    map[uuid.UUID]struct{}
	clearedusers    bool
	leader          *uuid.UUID
	clearedleader   bool
	done            bool
	oldValue        func(context.Context) (*Department, error)
	predicates      []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id uint32) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Department entities.
func (m *DepartmentMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DepartmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DepartmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DepartmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DepartmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DepartmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DepartmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DepartmentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DepartmentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DepartmentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[department.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DepartmentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[department.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DepartmentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, department.FieldDeletedAt)
}

// SetState sets the "state" field.
func (m *DepartmentMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *DepartmentMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *DepartmentMutation) ClearState() {
	m.state = nil
	m.clearedFields[department.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *DepartmentMutation) StateCleared() bool {
	_, ok := m.clearedFields[department.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *DepartmentMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, department.FieldState)
}

// SetSort sets the "sort" field.
func (m *DepartmentMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *DepartmentMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *DepartmentMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *DepartmentMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *DepartmentMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetDeptName sets the "dept_name" field.
func (m *DepartmentMutation) SetDeptName(s string) {
	m.dept_name = &s
}

// DeptName returns the value of the "dept_name" field in the mutation.
func (m *DepartmentMutation) DeptName() (r string, exists bool) {
	v := m.dept_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeptName returns the old "dept_name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDeptName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeptName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeptName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeptName: %w", err)
	}
	return oldValue.DeptName, nil
}

// ResetDeptName resets all changes to the "dept_name" field.
func (m *DepartmentMutation) ResetDeptName() {
	m.dept_name = nil
}

// SetDeptCode sets the "dept_code" field.
func (m *DepartmentMutation) SetDeptCode(s string) {
	m.dept_code = &s
}

// DeptCode returns the value of the "dept_code" field in the mutation.
func (m *DepartmentMutation) DeptCode() (r string, exists bool) {
	v := m.dept_code
	if v == nil {
		return
	}
	return *v, true
}

// OldDeptCode returns the old "dept_code" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDeptCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeptCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeptCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeptCode: %w", err)
	}
	return oldValue.DeptCode, nil
}

// ResetDeptCode resets all changes to the "dept_code" field.
func (m *DepartmentMutation) ResetDeptCode() {
	m.dept_code = nil
}

// SetParentID sets the "parent_id" field.
func (m *DepartmentMutation) SetParentID(u uint32) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *DepartmentMutation) ParentID() (r uint32, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldParentID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *DepartmentMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *DepartmentMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[department.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *DepartmentMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, department.FieldParentID)
}

// SetLeaderUserID sets the "leader_user_id" field.
func (m *DepartmentMutation) SetLeaderUserID(u uuid.UUID) {
	m.leader = &u
}

// LeaderUserID returns the value of the "leader_user_id" field in the mutation.
func (m *DepartmentMutation) LeaderUserID() (r uuid.UUID, exists bool) {
	v := m.leader
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaderUserID returns the old "leader_user_id" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldLeaderUserID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaderUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaderUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaderUserID: %w", err)
	}
	return oldValue.LeaderUserID, nil
}

// ClearLeaderUserID clears the value of the "leader_user_id" field.
func (m *DepartmentMutation) ClearLeaderUserID() {
	m.leader = nil
	m.clearedFields[department.FieldLeaderUserID] = struct{}{}
}

// LeaderUserIDCleared returns if the "leader_user_id" field was cleared in this mutation.
func (m *DepartmentMutation) LeaderUserIDCleared() bool {
	_, ok := m.clearedFields[department.FieldLeaderUserID]
	return ok
}

// ResetLeaderUserID resets all changes to the "leader_user_id" field.
func (m *DepartmentMutation) ResetLeaderUserID() {
	m.leader = nil
	delete(m.clearedFields, department.FieldLeaderUserID)
}

// SetDescription sets the "description" field.
func (m *DepartmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DepartmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DepartmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[department.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DepartmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[department.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DepartmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, department.FieldDescription)
}

// ClearParent clears the "parent" edge to the Department entity.
func (m *DepartmentMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[department.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Department entity was cleared.
func (m *DepartmentMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) ParentIDs() (ids []uint32) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *DepartmentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Department entity by ids.
func (m *DepartmentMutation) AddChildIDs(ids ...uint32) {
	if m.children == nil {
		m.children = make(map[uint32]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Department entity.
func (m *DepartmentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Department entity was cleared.
func (m *DepartmentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Department entity by IDs.
func (m *DepartmentMutation) RemoveChildIDs(ids ...uint32) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Department entity.
func (m *DepartmentMutation) RemovedChildrenIDs() (ids []uint32) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *DepartmentMutation) ChildrenIDs() (ids []uint32) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *DepartmentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *DepartmentMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *DepartmentMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *DepartmentMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *DepartmentMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *DepartmentMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *DepartmentMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *DepartmentMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// SetLeaderID sets the "leader" edge to the User entity by id.
func (m *DepartmentMutation) SetLeaderID(id uuid.UUID) {
	m.leader = &id
}

// ClearLeader clears the "leader" edge to the User entity.
func (m *DepartmentMutation) ClearLeader() {
	m.clearedleader = true
	m.clearedFields[department.FieldLeaderUserID] = struct{}{}
}

// LeaderCleared reports if the "leader" edge to the User entity was cleared.
func (m *DepartmentMutation) LeaderCleared() bool {
	return m.LeaderUserIDCleared() || m.clearedleader
}

// LeaderID returns the "leader" edge ID in the mutation.
func (m *DepartmentMutation) LeaderID() (id uuid.UUID, exists bool) {
	if m.leader != nil {
		return *m.leader, true
	}
	return
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *DepartmentMutation) LeaderIDs() (ids []uuid.UUID) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *DepartmentMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, department.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, department.FieldDeletedAt)
	}
	if m.state != nil {
		fields = append(fields, department.FieldState)
	}
	if m.sort != nil {
		fields = append(fields, department.FieldSort)
	}
	if m.dept_name != nil {
		fields = append(fields, department.FieldDeptName)
	}
	if m.dept_code != nil {
		fields = append(fields, department.FieldDeptCode)
	}
	if m.parent != nil {
		fields = append(fields, department.FieldParentID)
	}
	if m.leader != nil {
		fields = append(fields, department.FieldLeaderUserID)
	}
	if m.description != nil {
		fields = append(fields, department.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldCreatedAt:
		return m.CreatedAt()
	case department.FieldUpdatedAt:
		return m.UpdatedAt()
	case department.FieldDeletedAt:
		return m.DeletedAt()
	case department.FieldState:
		return m.State()
	case department.FieldSort:
		return m.Sort()
	case department.FieldDeptName:
		return m.DeptName()
	case department.FieldDeptCode:
		return m.DeptCode()
	case department.FieldParentID:
		return m.ParentID()
	case department.FieldLeaderUserID:
		return m.LeaderUserID()
	case department.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case department.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case department.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case department.FieldState:
		return m.OldState(ctx)
	case department.FieldSort:
		return m.OldSort(ctx)
	case department.FieldDeptName:
		return m.OldDeptName(ctx)
	case department.FieldDeptCode:
		return m.OldDeptCode(ctx)
	case department.FieldParentID:
		return m.OldParentID(ctx)
	case department.FieldLeaderUserID:
		return m.OldLeaderUserID(ctx)
	case department.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case department.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case department.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case department.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case department.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case department.FieldDeptName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeptName(v)
		return nil
	case department.FieldDeptCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeptCode(v)
		return nil
	case department.FieldParentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case department.FieldLeaderUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaderUserID(v)
		return nil
	case department.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, department.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case department.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case department.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldDeletedAt) {
		fields = append(fields, department.FieldDeletedAt)
	}
	if m.FieldCleared(department.FieldState) {
		fields = append(fields, department.FieldState)
	}
	if m.FieldCleared(department.FieldParentID) {
		fields = append(fields, department.FieldParentID)
	}
	if m.FieldCleared(department.FieldLeaderUserID) {
		fields = append(fields, department.FieldLeaderUserID)
	}
	if m.FieldCleared(department.FieldDescription) {
		fields = append(fields, department.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case department.FieldState:
		m.ClearState()
		return nil
	case department.FieldParentID:
		m.ClearParentID()
		return nil
	case department.FieldLeaderUserID:
		m.ClearLeaderUserID()
		return nil
	case department.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case department.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case department.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case department.FieldState:
		m.ResetState()
		return nil
	case department.FieldSort:
		m.ResetSort()
		return nil
	case department.FieldDeptName:
		m.ResetDeptName()
		return nil
	case department.FieldDeptCode:
		m.ResetDeptCode()
		return nil
	case department.FieldParentID:
		m.ResetParentID()
		return nil
	case department.FieldLeaderUserID:
		m.ResetLeaderUserID()
		return nil
	case department.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, department.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, department.EdgeChildren)
	}
	if m.users != nil {
		edges = append(edges, department.EdgeUsers)
	}
	if m.leader != nil {
		edges = append(edges, department.EdgeLeader)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, department.EdgeChildren)
	}
	if m.removedusers != nil {
		edges = append(edges, department.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, department.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, department.EdgeChildren)
	}
	if m.clearedusers {
		edges = append(edges, department.EdgeUsers)
	}
	if m.clearedleader {
		edges = append(edges, department.EdgeLeader)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeParent:
		return m.clearedparent
	case department.EdgeChildren:
		return m.clearedchildren
	case department.EdgeUsers:
		return m.clearedusers
	case department.EdgeLeader:
		return m.clearedleader
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	case department.EdgeParent:
		m.ClearParent()
		return nil
	case department.EdgeLeader:
		m.ClearLeader()
		return nil
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeParent:
		m.ResetParent()
		return nil
	case department.EdgeChildren:
		m.ResetChildren()
		return nil
	case department.EdgeUsers:
		m.ResetUsers()
		return nil
	case department.EdgeLeader:
		m.ResetLeader()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DictItemMutation represents an operation that mutates the DictItem nodes in the graph.
type DictItemMutation struct {
	config
	op               Op
	typ              string
	id               *uint32
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	state            *bool
	item_label       *string
	item_value       *string
	item_color       *string
	item_css         *string
	sort_order       *int
	addsort_order    *int
	description      *string
	clearedFields    map[string]struct{}
	dict_type        *uint32
	cleareddict_type bool
	done             bool
	oldValue         func(context.Context) (*DictItem, error)
	predicates       []predicate.DictItem
}

var _ ent.Mutation = (*DictItemMutation)(nil)

// dictitemOption allows management of the mutation configuration using functional options.
type dictitemOption func(*DictItemMutation)

// newDictItemMutation creates new mutation for the DictItem entity.
func newDictItemMutation(c config, op Op, opts ...dictitemOption) *DictItemMutation {
	m := &DictItemMutation{
		config:        c,
		op:            op,
		typ:           TypeDictItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictItemID sets the ID field of the mutation.
func withDictItemID(id uint32) dictitemOption {
	return func(m *DictItemMutation) {
		var (
			err   error
			once  sync.Once
			value *DictItem
		)
		m.oldValue = func(ctx context.Context) (*DictItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictItem sets the old DictItem of the mutation.
func withDictItem(node *DictItem) dictitemOption {
	return func(m *DictItemMutation) {
		m.oldValue = func(context.Context) (*DictItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictItem entities.
func (m *DictItemMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictItemMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictItemMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictItem entity.
// If the DictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictItem entity.
// If the DictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DictItemMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DictItemMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DictItem entity.
// If the DictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictItemMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DictItemMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dictitem.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DictItemMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dictitem.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DictItemMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dictitem.FieldDeletedAt)
}

// SetState sets the "state" field.
func (m *DictItemMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *DictItemMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the DictItem entity.
// If the DictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictItemMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *DictItemMutation) ClearState() {
	m.state = nil
	m.clearedFields[dictitem.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *DictItemMutation) StateCleared() bool {
	_, ok := m.clearedFields[dictitem.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *DictItemMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, dictitem.FieldState)
}

// SetItemLabel sets the "item_label" field.
func (m *DictItemMutation) SetItemLabel(s string) {
	m.item_label = &s
}

// ItemLabel returns the value of the "item_label" field in the mutation.
func (m *DictItemMutation) ItemLabel() (r string, exists bool) {
	v := m.item_label
	if v == nil {
		return
	}
	return *v, true
}

// OldItemLabel returns the old "item_label" field's value of the DictItem entity.
// If the DictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictItemMutation) OldItemLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemLabel: %w", err)
	}
	return oldValue.ItemLabel, nil
}

// ResetItemLabel resets all changes to the "item_label" field.
func (m *DictItemMutation) ResetItemLabel() {
	m.item_label = nil
}

// SetItemValue sets the "item_value" field.
func (m *DictItemMutation) SetItemValue(s string) {
	m.item_value = &s
}

// ItemValue returns the value of the "item_value" field in the mutation.
func (m *DictItemMutation) ItemValue() (r string, exists bool) {
	v := m.item_value
	if v == nil {
		return
	}
	return *v, true
}

// OldItemValue returns the old "item_value" field's value of the DictItem entity.
// If the DictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictItemMutation) OldItemValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemValue: %w", err)
	}
	return oldValue.ItemValue, nil
}

// ResetItemValue resets all changes to the "item_value" field.
func (m *DictItemMutation) ResetItemValue() {
	m.item_value = nil
}

// SetItemColor sets the "item_color" field.
func (m *DictItemMutation) SetItemColor(s string) {
	m.item_color = &s
}

// ItemColor returns the value of the "item_color" field in the mutation.
func (m *DictItemMutation) ItemColor() (r string, exists bool) {
	v := m.item_color
	if v == nil {
		return
	}
	return *v, true
}

// OldItemColor returns the old "item_color" field's value of the DictItem entity.
// If the DictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictItemMutation) OldItemColor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemColor: %w", err)
	}
	return oldValue.ItemColor, nil
}

// ClearItemColor clears the value of the "item_color" field.
func (m *DictItemMutation) ClearItemColor() {
	m.item_color = nil
	m.clearedFields[dictitem.FieldItemColor] = struct{}{}
}

// ItemColorCleared returns if the "item_color" field was cleared in this mutation.
func (m *DictItemMutation) ItemColorCleared() bool {
	_, ok := m.clearedFields[dictitem.FieldItemColor]
	return ok
}

// ResetItemColor resets all changes to the "item_color" field.
func (m *DictItemMutation) ResetItemColor() {
	m.item_color = nil
	delete(m.clearedFields, dictitem.FieldItemColor)
}

// SetItemCSS sets the "item_css" field.
func (m *DictItemMutation) SetItemCSS(s string) {
	m.item_css = &s
}

// ItemCSS returns the value of the "item_css" field in the mutation.
func (m *DictItemMutation) ItemCSS() (r string, exists bool) {
	v := m.item_css
	if v == nil {
		return
	}
	return *v, true
}

// OldItemCSS returns the old "item_css" field's value of the DictItem entity.
// If the DictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictItemMutation) OldItemCSS(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemCSS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemCSS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemCSS: %w", err)
	}
	return oldValue.ItemCSS, nil
}

// ClearItemCSS clears the value of the "item_css" field.
func (m *DictItemMutation) ClearItemCSS() {
	m.item_css = nil
	m.clearedFields[dictitem.FieldItemCSS] = struct{}{}
}

// ItemCSSCleared returns if the "item_css" field was cleared in this mutation.
func (m *DictItemMutation) ItemCSSCleared() bool {
	_, ok := m.clearedFields[dictitem.FieldItemCSS]
	return ok
}

// ResetItemCSS resets all changes to the "item_css" field.
func (m *DictItemMutation) ResetItemCSS() {
	m.item_css = nil
	delete(m.clearedFields, dictitem.FieldItemCSS)
}

// SetSortOrder sets the "sort_order" field.
func (m *DictItemMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *DictItemMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the DictItem entity.
// If the DictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictItemMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *DictItemMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *DictItemMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *DictItemMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetDescription sets the "description" field.
func (m *DictItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DictItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DictItem entity.
// If the DictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictItemMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DictItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[dictitem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DictItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[dictitem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DictItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, dictitem.FieldDescription)
}

// SetDictTypeID sets the "dict_type_id" field.
func (m *DictItemMutation) SetDictTypeID(u uint32) {
	m.dict_type = &u
}

// DictTypeID returns the value of the "dict_type_id" field in the mutation.
func (m *DictItemMutation) DictTypeID() (r uint32, exists bool) {
	v := m.dict_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDictTypeID returns the old "dict_type_id" field's value of the DictItem entity.
// If the DictItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictItemMutation) OldDictTypeID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictTypeID: %w", err)
	}
	return oldValue.DictTypeID, nil
}

// ResetDictTypeID resets all changes to the "dict_type_id" field.
func (m *DictItemMutation) ResetDictTypeID() {
	m.dict_type = nil
}

// ClearDictType clears the "dict_type" edge to the DictType entity.
func (m *DictItemMutation) ClearDictType() {
	m.cleareddict_type = true
	m.clearedFields[dictitem.FieldDictTypeID] = struct{}{}
}

// DictTypeCleared reports if the "dict_type" edge to the DictType entity was cleared.
func (m *DictItemMutation) DictTypeCleared() bool {
	return m.cleareddict_type
}

// DictTypeIDs returns the "dict_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictTypeID instead. It exists only for internal usage by the builders.
func (m *DictItemMutation) DictTypeIDs() (ids []uint32) {
	if id := m.dict_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictType resets all changes to the "dict_type" edge.
func (m *DictItemMutation) ResetDictType() {
	m.dict_type = nil
	m.cleareddict_type = false
}

// Where appends a list predicates to the DictItemMutation builder.
func (m *DictItemMutation) Where(ps ...predicate.DictItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictItem).
func (m *DictItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictItemMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, dictitem.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictitem.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dictitem.FieldDeletedAt)
	}
	if m.state != nil {
		fields = append(fields, dictitem.FieldState)
	}
	if m.item_label != nil {
		fields = append(fields, dictitem.FieldItemLabel)
	}
	if m.item_value != nil {
		fields = append(fields, dictitem.FieldItemValue)
	}
	if m.item_color != nil {
		fields = append(fields, dictitem.FieldItemColor)
	}
	if m.item_css != nil {
		fields = append(fields, dictitem.FieldItemCSS)
	}
	if m.sort_order != nil {
		fields = append(fields, dictitem.FieldSortOrder)
	}
	if m.description != nil {
		fields = append(fields, dictitem.FieldDescription)
	}
	if m.dict_type != nil {
		fields = append(fields, dictitem.FieldDictTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictitem.FieldCreatedAt:
		return m.CreatedAt()
	case dictitem.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictitem.FieldDeletedAt:
		return m.DeletedAt()
	case dictitem.FieldState:
		return m.State()
	case dictitem.FieldItemLabel:
		return m.ItemLabel()
	case dictitem.FieldItemValue:
		return m.ItemValue()
	case dictitem.FieldItemColor:
		return m.ItemColor()
	case dictitem.FieldItemCSS:
		return m.ItemCSS()
	case dictitem.FieldSortOrder:
		return m.SortOrder()
	case dictitem.FieldDescription:
		return m.Description()
	case dictitem.FieldDictTypeID:
		return m.DictTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictitem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictitem.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dictitem.FieldState:
		return m.OldState(ctx)
	case dictitem.FieldItemLabel:
		return m.OldItemLabel(ctx)
	case dictitem.FieldItemValue:
		return m.OldItemValue(ctx)
	case dictitem.FieldItemColor:
		return m.OldItemColor(ctx)
	case dictitem.FieldItemCSS:
		return m.OldItemCSS(ctx)
	case dictitem.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case dictitem.FieldDescription:
		return m.OldDescription(ctx)
	case dictitem.FieldDictTypeID:
		return m.OldDictTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown DictItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictitem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictitem.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dictitem.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case dictitem.FieldItemLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemLabel(v)
		return nil
	case dictitem.FieldItemValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemValue(v)
		return nil
	case dictitem.FieldItemColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemColor(v)
		return nil
	case dictitem.FieldItemCSS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemCSS(v)
		return nil
	case dictitem.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case dictitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case dictitem.FieldDictTypeID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown DictItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictItemMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, dictitem.FieldSortOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictitem.FieldSortOrder:
		return m.AddedSortOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictitem.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	}
	return fmt.Errorf("unknown DictItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictitem.FieldDeletedAt) {
		fields = append(fields, dictitem.FieldDeletedAt)
	}
	if m.FieldCleared(dictitem.FieldState) {
		fields = append(fields, dictitem.FieldState)
	}
	if m.FieldCleared(dictitem.FieldItemColor) {
		fields = append(fields, dictitem.FieldItemColor)
	}
	if m.FieldCleared(dictitem.FieldItemCSS) {
		fields = append(fields, dictitem.FieldItemCSS)
	}
	if m.FieldCleared(dictitem.FieldDescription) {
		fields = append(fields, dictitem.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictItemMutation) ClearField(name string) error {
	switch name {
	case dictitem.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dictitem.FieldState:
		m.ClearState()
		return nil
	case dictitem.FieldItemColor:
		m.ClearItemColor()
		return nil
	case dictitem.FieldItemCSS:
		m.ClearItemCSS()
		return nil
	case dictitem.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DictItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictItemMutation) ResetField(name string) error {
	switch name {
	case dictitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictitem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictitem.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dictitem.FieldState:
		m.ResetState()
		return nil
	case dictitem.FieldItemLabel:
		m.ResetItemLabel()
		return nil
	case dictitem.FieldItemValue:
		m.ResetItemValue()
		return nil
	case dictitem.FieldItemColor:
		m.ResetItemColor()
		return nil
	case dictitem.FieldItemCSS:
		m.ResetItemCSS()
		return nil
	case dictitem.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case dictitem.FieldDescription:
		m.ResetDescription()
		return nil
	case dictitem.FieldDictTypeID:
		m.ResetDictTypeID()
		return nil
	}
	return fmt.Errorf("unknown DictItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dict_type != nil {
		edges = append(edges, dictitem.EdgeDictType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictitem.EdgeDictType:
		if id := m.dict_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddict_type {
		edges = append(edges, dictitem.EdgeDictType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictItemMutation) EdgeCleared(name string) bool {
	switch name {
	case dictitem.EdgeDictType:
		return m.cleareddict_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictItemMutation) ClearEdge(name string) error {
	switch name {
	case dictitem.EdgeDictType:
		m.ClearDictType()
		return nil
	}
	return fmt.Errorf("unknown DictItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictItemMutation) ResetEdge(name string) error {
	switch name {
	case dictitem.EdgeDictType:
		m.ResetDictType()
		return nil
	}
	return fmt.Errorf("unknown DictItem edge %s", name)
}

// DictTypeMutation represents an operation that mutates the DictType nodes in the graph.
type DictTypeMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	state             *bool
	dict_type_code    *string
	dict_type_name    *string
	description       *string
	clearedFields     map[string]struct{}
	dict_items        map[uint32]struct{}
	removeddict_items map[uint32]struct{}
	cleareddict_items bool
	done              bool
	oldValue          func(context.Context) (*DictType, error)
	predicates        []predicate.DictType
}

var _ ent.Mutation = (*DictTypeMutation)(nil)

// dicttypeOption allows management of the mutation configuration using functional options.
type dicttypeOption func(*DictTypeMutation)

// newDictTypeMutation creates new mutation for the DictType entity.
func newDictTypeMutation(c config, op Op, opts ...dicttypeOption) *DictTypeMutation {
	m := &DictTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeDictType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictTypeID sets the ID field of the mutation.
func withDictTypeID(id uint32) dicttypeOption {
	return func(m *DictTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *DictType
		)
		m.oldValue = func(ctx context.Context) (*DictType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DictType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictType sets the old DictType of the mutation.
func withDictType(node *DictType) dicttypeOption {
	return func(m *DictTypeMutation) {
		m.oldValue = func(context.Context) (*DictType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DictType entities.
func (m *DictTypeMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictTypeMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictTypeMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DictType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *DictTypeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *DictTypeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *DictTypeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[dicttype.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *DictTypeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *DictTypeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, dicttype.FieldDeletedAt)
}

// SetState sets the "state" field.
func (m *DictTypeMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *DictTypeMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *DictTypeMutation) ClearState() {
	m.state = nil
	m.clearedFields[dicttype.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *DictTypeMutation) StateCleared() bool {
	_, ok := m.clearedFields[dicttype.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *DictTypeMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, dicttype.FieldState)
}

// SetDictTypeCode sets the "dict_type_code" field.
func (m *DictTypeMutation) SetDictTypeCode(s string) {
	m.dict_type_code = &s
}

// DictTypeCode returns the value of the "dict_type_code" field in the mutation.
func (m *DictTypeMutation) DictTypeCode() (r string, exists bool) {
	v := m.dict_type_code
	if v == nil {
		return
	}
	return *v, true
}

// OldDictTypeCode returns the old "dict_type_code" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldDictTypeCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictTypeCode: %w", err)
	}
	return oldValue.DictTypeCode, nil
}

// ResetDictTypeCode resets all changes to the "dict_type_code" field.
func (m *DictTypeMutation) ResetDictTypeCode() {
	m.dict_type_code = nil
}

// SetDictTypeName sets the "dict_type_name" field.
func (m *DictTypeMutation) SetDictTypeName(s string) {
	m.dict_type_name = &s
}

// DictTypeName returns the value of the "dict_type_name" field in the mutation.
func (m *DictTypeMutation) DictTypeName() (r string, exists bool) {
	v := m.dict_type_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDictTypeName returns the old "dict_type_name" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldDictTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictTypeName: %w", err)
	}
	return oldValue.DictTypeName, nil
}

// ResetDictTypeName resets all changes to the "dict_type_name" field.
func (m *DictTypeMutation) ResetDictTypeName() {
	m.dict_type_name = nil
}

// SetDescription sets the "description" field.
func (m *DictTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DictTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DictType entity.
// If the DictType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DictTypeMutation) ResetDescription() {
	m.description = nil
}

// AddDictItemIDs adds the "dict_items" edge to the DictItem entity by ids.
func (m *DictTypeMutation) AddDictItemIDs(ids ...uint32) {
	if m.dict_items == nil {
		m.dict_items = make(map[uint32]struct{})
	}
	for i := range ids {
		m.dict_items[ids[i]] = struct{}{}
	}
}

// ClearDictItems clears the "dict_items" edge to the DictItem entity.
func (m *DictTypeMutation) ClearDictItems() {
	m.cleareddict_items = true
}

// DictItemsCleared reports if the "dict_items" edge to the DictItem entity was cleared.
func (m *DictTypeMutation) DictItemsCleared() bool {
	return m.cleareddict_items
}

// RemoveDictItemIDs removes the "dict_items" edge to the DictItem entity by IDs.
func (m *DictTypeMutation) RemoveDictItemIDs(ids ...uint32) {
	if m.removeddict_items == nil {
		m.removeddict_items = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.dict_items, ids[i])
		m.removeddict_items[ids[i]] = struct{}{}
	}
}

// RemovedDictItems returns the removed IDs of the "dict_items" edge to the DictItem entity.
func (m *DictTypeMutation) RemovedDictItemsIDs() (ids []uint32) {
	for id := range m.removeddict_items {
		ids = append(ids, id)
	}
	return
}

// DictItemsIDs returns the "dict_items" edge IDs in the mutation.
func (m *DictTypeMutation) DictItemsIDs() (ids []uint32) {
	for id := range m.dict_items {
		ids = append(ids, id)
	}
	return
}

// ResetDictItems resets all changes to the "dict_items" edge.
func (m *DictTypeMutation) ResetDictItems() {
	m.dict_items = nil
	m.cleareddict_items = false
	m.removeddict_items = nil
}

// Where appends a list predicates to the DictTypeMutation builder.
func (m *DictTypeMutation) Where(ps ...predicate.DictType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DictType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DictType).
func (m *DictTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, dicttype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dicttype.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, dicttype.FieldDeletedAt)
	}
	if m.state != nil {
		fields = append(fields, dicttype.FieldState)
	}
	if m.dict_type_code != nil {
		fields = append(fields, dicttype.FieldDictTypeCode)
	}
	if m.dict_type_name != nil {
		fields = append(fields, dicttype.FieldDictTypeName)
	}
	if m.description != nil {
		fields = append(fields, dicttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dicttype.FieldCreatedAt:
		return m.CreatedAt()
	case dicttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case dicttype.FieldDeletedAt:
		return m.DeletedAt()
	case dicttype.FieldState:
		return m.State()
	case dicttype.FieldDictTypeCode:
		return m.DictTypeCode()
	case dicttype.FieldDictTypeName:
		return m.DictTypeName()
	case dicttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dicttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dicttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dicttype.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case dicttype.FieldState:
		return m.OldState(ctx)
	case dicttype.FieldDictTypeCode:
		return m.OldDictTypeCode(ctx)
	case dicttype.FieldDictTypeName:
		return m.OldDictTypeName(ctx)
	case dicttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown DictType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dicttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dicttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dicttype.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case dicttype.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case dicttype.FieldDictTypeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictTypeCode(v)
		return nil
	case dicttype.FieldDictTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictTypeName(v)
		return nil
	case dicttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown DictType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DictType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dicttype.FieldDeletedAt) {
		fields = append(fields, dicttype.FieldDeletedAt)
	}
	if m.FieldCleared(dicttype.FieldState) {
		fields = append(fields, dicttype.FieldState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictTypeMutation) ClearField(name string) error {
	switch name {
	case dicttype.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case dicttype.FieldState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown DictType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictTypeMutation) ResetField(name string) error {
	switch name {
	case dicttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dicttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dicttype.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case dicttype.FieldState:
		m.ResetState()
		return nil
	case dicttype.FieldDictTypeCode:
		m.ResetDictTypeCode()
		return nil
	case dicttype.FieldDictTypeName:
		m.ResetDictTypeName()
		return nil
	case dicttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown DictType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dict_items != nil {
		edges = append(edges, dicttype.EdgeDictItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dicttype.EdgeDictItems:
		ids := make([]ent.Value, 0, len(m.dict_items))
		for id := range m.dict_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddict_items != nil {
		edges = append(edges, dicttype.EdgeDictItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dicttype.EdgeDictItems:
		ids := make([]ent.Value, 0, len(m.removeddict_items))
		for id := range m.removeddict_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddict_items {
		edges = append(edges, dicttype.EdgeDictItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case dicttype.EdgeDictItems:
		return m.cleareddict_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DictType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictTypeMutation) ResetEdge(name string) error {
	switch name {
	case dicttype.EdgeDictItems:
		m.ResetDictItems()
		return nil
	}
	return fmt.Errorf("unknown DictType edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *time.Time
	updated_at      *time.Time
	state           *bool
	sort            *int32
	addsort         *int32
	menu_code       *string
	menu_name       *string
	menu_path       *string
	component       *string
	redirect        *string
	menu_level      *uint16
	addmenu_level   *int16
	icon            *string
	permission      *string
	service_name    *string
	menu_type       *string
	is_hidden       *bool
	is_breadcrumb   *bool
	is_cache        *bool
	is_tab          *bool
	is_affix        *bool
	frame_src       *string
	description     *string
	link            *string
	clearedFields   map[string]struct{}
	parent          *uint32
	clearedparent   bool
	children        map[uint32]struct{}
	removedchildren map[uint32]struct{}
	clearedchildren bool
	roles           map[uint32]struct{}
	removedroles    map[uint32]struct{}
	clearedroles    bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id uint32) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetState sets the "state" field.
func (m *MenuMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *MenuMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *MenuMutation) ClearState() {
	m.state = nil
	m.clearedFields[menu.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *MenuMutation) StateCleared() bool {
	_, ok := m.clearedFields[menu.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *MenuMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, menu.FieldState)
}

// SetSort sets the "sort" field.
func (m *MenuMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *MenuMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *MenuMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *MenuMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *MenuMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetMenuCode sets the "menu_code" field.
func (m *MenuMutation) SetMenuCode(s string) {
	m.menu_code = &s
}

// MenuCode returns the value of the "menu_code" field in the mutation.
func (m *MenuMutation) MenuCode() (r string, exists bool) {
	v := m.menu_code
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuCode returns the old "menu_code" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuCode: %w", err)
	}
	return oldValue.MenuCode, nil
}

// ResetMenuCode resets all changes to the "menu_code" field.
func (m *MenuMutation) ResetMenuCode() {
	m.menu_code = nil
}

// SetMenuName sets the "menu_name" field.
func (m *MenuMutation) SetMenuName(s string) {
	m.menu_name = &s
}

// MenuName returns the value of the "menu_name" field in the mutation.
func (m *MenuMutation) MenuName() (r string, exists bool) {
	v := m.menu_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuName returns the old "menu_name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuName: %w", err)
	}
	return oldValue.MenuName, nil
}

// ResetMenuName resets all changes to the "menu_name" field.
func (m *MenuMutation) ResetMenuName() {
	m.menu_name = nil
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(u uint32) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r uint32, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetMenuPath sets the "menu_path" field.
func (m *MenuMutation) SetMenuPath(s string) {
	m.menu_path = &s
}

// MenuPath returns the value of the "menu_path" field in the mutation.
func (m *MenuMutation) MenuPath() (r string, exists bool) {
	v := m.menu_path
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuPath returns the old "menu_path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuPath: %w", err)
	}
	return oldValue.MenuPath, nil
}

// ClearMenuPath clears the value of the "menu_path" field.
func (m *MenuMutation) ClearMenuPath() {
	m.menu_path = nil
	m.clearedFields[menu.FieldMenuPath] = struct{}{}
}

// MenuPathCleared returns if the "menu_path" field was cleared in this mutation.
func (m *MenuMutation) MenuPathCleared() bool {
	_, ok := m.clearedFields[menu.FieldMenuPath]
	return ok
}

// ResetMenuPath resets all changes to the "menu_path" field.
func (m *MenuMutation) ResetMenuPath() {
	m.menu_path = nil
	delete(m.clearedFields, menu.FieldMenuPath)
}

// SetComponent sets the "component" field.
func (m *MenuMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the value of the "component" field in the mutation.
func (m *MenuMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldComponent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ClearComponent clears the value of the "component" field.
func (m *MenuMutation) ClearComponent() {
	m.component = nil
	m.clearedFields[menu.FieldComponent] = struct{}{}
}

// ComponentCleared returns if the "component" field was cleared in this mutation.
func (m *MenuMutation) ComponentCleared() bool {
	_, ok := m.clearedFields[menu.FieldComponent]
	return ok
}

// ResetComponent resets all changes to the "component" field.
func (m *MenuMutation) ResetComponent() {
	m.component = nil
	delete(m.clearedFields, menu.FieldComponent)
}

// SetRedirect sets the "redirect" field.
func (m *MenuMutation) SetRedirect(s string) {
	m.redirect = &s
}

// Redirect returns the value of the "redirect" field in the mutation.
func (m *MenuMutation) Redirect() (r string, exists bool) {
	v := m.redirect
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirect returns the old "redirect" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRedirect(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirect: %w", err)
	}
	return oldValue.Redirect, nil
}

// ClearRedirect clears the value of the "redirect" field.
func (m *MenuMutation) ClearRedirect() {
	m.redirect = nil
	m.clearedFields[menu.FieldRedirect] = struct{}{}
}

// RedirectCleared returns if the "redirect" field was cleared in this mutation.
func (m *MenuMutation) RedirectCleared() bool {
	_, ok := m.clearedFields[menu.FieldRedirect]
	return ok
}

// ResetRedirect resets all changes to the "redirect" field.
func (m *MenuMutation) ResetRedirect() {
	m.redirect = nil
	delete(m.clearedFields, menu.FieldRedirect)
}

// SetMenuLevel sets the "menu_level" field.
func (m *MenuMutation) SetMenuLevel(u uint16) {
	m.menu_level = &u
	m.addmenu_level = nil
}

// MenuLevel returns the value of the "menu_level" field in the mutation.
func (m *MenuMutation) MenuLevel() (r uint16, exists bool) {
	v := m.menu_level
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuLevel returns the old "menu_level" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuLevel(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuLevel: %w", err)
	}
	return oldValue.MenuLevel, nil
}

// AddMenuLevel adds u to the "menu_level" field.
func (m *MenuMutation) AddMenuLevel(u int16) {
	if m.addmenu_level != nil {
		*m.addmenu_level += u
	} else {
		m.addmenu_level = &u
	}
}

// AddedMenuLevel returns the value that was added to the "menu_level" field in this mutation.
func (m *MenuMutation) AddedMenuLevel() (r int16, exists bool) {
	v := m.addmenu_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetMenuLevel resets all changes to the "menu_level" field.
func (m *MenuMutation) ResetMenuLevel() {
	m.menu_level = nil
	m.addmenu_level = nil
}

// SetIcon sets the "icon" field.
func (m *MenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *MenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIcon(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *MenuMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[menu.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *MenuMutation) IconCleared() bool {
	_, ok := m.clearedFields[menu.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *MenuMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, menu.FieldIcon)
}

// SetPermission sets the "permission" field.
func (m *MenuMutation) SetPermission(s string) {
	m.permission = &s
}

// Permission returns the value of the "permission" field in the mutation.
func (m *MenuMutation) Permission() (r string, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermission returns the old "permission" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPermission(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermission: %w", err)
	}
	return oldValue.Permission, nil
}

// ClearPermission clears the value of the "permission" field.
func (m *MenuMutation) ClearPermission() {
	m.permission = nil
	m.clearedFields[menu.FieldPermission] = struct{}{}
}

// PermissionCleared returns if the "permission" field was cleared in this mutation.
func (m *MenuMutation) PermissionCleared() bool {
	_, ok := m.clearedFields[menu.FieldPermission]
	return ok
}

// ResetPermission resets all changes to the "permission" field.
func (m *MenuMutation) ResetPermission() {
	m.permission = nil
	delete(m.clearedFields, menu.FieldPermission)
}

// SetServiceName sets the "service_name" field.
func (m *MenuMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *MenuMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldServiceName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ClearServiceName clears the value of the "service_name" field.
func (m *MenuMutation) ClearServiceName() {
	m.service_name = nil
	m.clearedFields[menu.FieldServiceName] = struct{}{}
}

// ServiceNameCleared returns if the "service_name" field was cleared in this mutation.
func (m *MenuMutation) ServiceNameCleared() bool {
	_, ok := m.clearedFields[menu.FieldServiceName]
	return ok
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *MenuMutation) ResetServiceName() {
	m.service_name = nil
	delete(m.clearedFields, menu.FieldServiceName)
}

// SetMenuType sets the "menu_type" field.
func (m *MenuMutation) SetMenuType(s string) {
	m.menu_type = &s
}

// MenuType returns the value of the "menu_type" field in the mutation.
func (m *MenuMutation) MenuType() (r string, exists bool) {
	v := m.menu_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuType returns the old "menu_type" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMenuType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuType: %w", err)
	}
	return oldValue.MenuType, nil
}

// ResetMenuType resets all changes to the "menu_type" field.
func (m *MenuMutation) ResetMenuType() {
	m.menu_type = nil
}

// SetIsHidden sets the "is_hidden" field.
func (m *MenuMutation) SetIsHidden(b bool) {
	m.is_hidden = &b
}

// IsHidden returns the value of the "is_hidden" field in the mutation.
func (m *MenuMutation) IsHidden() (r bool, exists bool) {
	v := m.is_hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHidden returns the old "is_hidden" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIsHidden(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHidden: %w", err)
	}
	return oldValue.IsHidden, nil
}

// ClearIsHidden clears the value of the "is_hidden" field.
func (m *MenuMutation) ClearIsHidden() {
	m.is_hidden = nil
	m.clearedFields[menu.FieldIsHidden] = struct{}{}
}

// IsHiddenCleared returns if the "is_hidden" field was cleared in this mutation.
func (m *MenuMutation) IsHiddenCleared() bool {
	_, ok := m.clearedFields[menu.FieldIsHidden]
	return ok
}

// ResetIsHidden resets all changes to the "is_hidden" field.
func (m *MenuMutation) ResetIsHidden() {
	m.is_hidden = nil
	delete(m.clearedFields, menu.FieldIsHidden)
}

// SetIsBreadcrumb sets the "is_breadcrumb" field.
func (m *MenuMutation) SetIsBreadcrumb(b bool) {
	m.is_breadcrumb = &b
}

// IsBreadcrumb returns the value of the "is_breadcrumb" field in the mutation.
func (m *MenuMutation) IsBreadcrumb() (r bool, exists bool) {
	v := m.is_breadcrumb
	if v == nil {
		return
	}
	return *v, true
}

// OldIsBreadcrumb returns the old "is_breadcrumb" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIsBreadcrumb(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsBreadcrumb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsBreadcrumb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsBreadcrumb: %w", err)
	}
	return oldValue.IsBreadcrumb, nil
}

// ClearIsBreadcrumb clears the value of the "is_breadcrumb" field.
func (m *MenuMutation) ClearIsBreadcrumb() {
	m.is_breadcrumb = nil
	m.clearedFields[menu.FieldIsBreadcrumb] = struct{}{}
}

// IsBreadcrumbCleared returns if the "is_breadcrumb" field was cleared in this mutation.
func (m *MenuMutation) IsBreadcrumbCleared() bool {
	_, ok := m.clearedFields[menu.FieldIsBreadcrumb]
	return ok
}

// ResetIsBreadcrumb resets all changes to the "is_breadcrumb" field.
func (m *MenuMutation) ResetIsBreadcrumb() {
	m.is_breadcrumb = nil
	delete(m.clearedFields, menu.FieldIsBreadcrumb)
}

// SetIsCache sets the "is_cache" field.
func (m *MenuMutation) SetIsCache(b bool) {
	m.is_cache = &b
}

// IsCache returns the value of the "is_cache" field in the mutation.
func (m *MenuMutation) IsCache() (r bool, exists bool) {
	v := m.is_cache
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCache returns the old "is_cache" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIsCache(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCache is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCache requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCache: %w", err)
	}
	return oldValue.IsCache, nil
}

// ClearIsCache clears the value of the "is_cache" field.
func (m *MenuMutation) ClearIsCache() {
	m.is_cache = nil
	m.clearedFields[menu.FieldIsCache] = struct{}{}
}

// IsCacheCleared returns if the "is_cache" field was cleared in this mutation.
func (m *MenuMutation) IsCacheCleared() bool {
	_, ok := m.clearedFields[menu.FieldIsCache]
	return ok
}

// ResetIsCache resets all changes to the "is_cache" field.
func (m *MenuMutation) ResetIsCache() {
	m.is_cache = nil
	delete(m.clearedFields, menu.FieldIsCache)
}

// SetIsTab sets the "is_tab" field.
func (m *MenuMutation) SetIsTab(b bool) {
	m.is_tab = &b
}

// IsTab returns the value of the "is_tab" field in the mutation.
func (m *MenuMutation) IsTab() (r bool, exists bool) {
	v := m.is_tab
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTab returns the old "is_tab" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIsTab(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTab is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTab requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTab: %w", err)
	}
	return oldValue.IsTab, nil
}

// ClearIsTab clears the value of the "is_tab" field.
func (m *MenuMutation) ClearIsTab() {
	m.is_tab = nil
	m.clearedFields[menu.FieldIsTab] = struct{}{}
}

// IsTabCleared returns if the "is_tab" field was cleared in this mutation.
func (m *MenuMutation) IsTabCleared() bool {
	_, ok := m.clearedFields[menu.FieldIsTab]
	return ok
}

// ResetIsTab resets all changes to the "is_tab" field.
func (m *MenuMutation) ResetIsTab() {
	m.is_tab = nil
	delete(m.clearedFields, menu.FieldIsTab)
}

// SetIsAffix sets the "is_affix" field.
func (m *MenuMutation) SetIsAffix(b bool) {
	m.is_affix = &b
}

// IsAffix returns the value of the "is_affix" field in the mutation.
func (m *MenuMutation) IsAffix() (r bool, exists bool) {
	v := m.is_affix
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAffix returns the old "is_affix" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIsAffix(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAffix: %w", err)
	}
	return oldValue.IsAffix, nil
}

// ClearIsAffix clears the value of the "is_affix" field.
func (m *MenuMutation) ClearIsAffix() {
	m.is_affix = nil
	m.clearedFields[menu.FieldIsAffix] = struct{}{}
}

// IsAffixCleared returns if the "is_affix" field was cleared in this mutation.
func (m *MenuMutation) IsAffixCleared() bool {
	_, ok := m.clearedFields[menu.FieldIsAffix]
	return ok
}

// ResetIsAffix resets all changes to the "is_affix" field.
func (m *MenuMutation) ResetIsAffix() {
	m.is_affix = nil
	delete(m.clearedFields, menu.FieldIsAffix)
}

// SetFrameSrc sets the "frame_src" field.
func (m *MenuMutation) SetFrameSrc(s string) {
	m.frame_src = &s
}

// FrameSrc returns the value of the "frame_src" field in the mutation.
func (m *MenuMutation) FrameSrc() (r string, exists bool) {
	v := m.frame_src
	if v == nil {
		return
	}
	return *v, true
}

// OldFrameSrc returns the old "frame_src" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldFrameSrc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrameSrc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrameSrc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrameSrc: %w", err)
	}
	return oldValue.FrameSrc, nil
}

// ClearFrameSrc clears the value of the "frame_src" field.
func (m *MenuMutation) ClearFrameSrc() {
	m.frame_src = nil
	m.clearedFields[menu.FieldFrameSrc] = struct{}{}
}

// FrameSrcCleared returns if the "frame_src" field was cleared in this mutation.
func (m *MenuMutation) FrameSrcCleared() bool {
	_, ok := m.clearedFields[menu.FieldFrameSrc]
	return ok
}

// ResetFrameSrc resets all changes to the "frame_src" field.
func (m *MenuMutation) ResetFrameSrc() {
	m.frame_src = nil
	delete(m.clearedFields, menu.FieldFrameSrc)
}

// SetDescription sets the "description" field.
func (m *MenuMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MenuMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MenuMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[menu.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MenuMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[menu.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MenuMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, menu.FieldDescription)
}

// SetLink sets the "link" field.
func (m *MenuMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *MenuMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldLink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *MenuMutation) ClearLink() {
	m.link = nil
	m.clearedFields[menu.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *MenuMutation) LinkCleared() bool {
	_, ok := m.clearedFields[menu.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *MenuMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, menu.FieldLink)
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []uint32) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...uint32) {
	if m.children == nil {
		m.children = make(map[uint32]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...uint32) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []uint32) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []uint32) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *MenuMutation) AddRoleIDs(ids ...uint32) {
	if m.roles == nil {
		m.roles = make(map[uint32]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *MenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *MenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *MenuMutation) RemoveRoleIDs(ids ...uint32) {
	if m.removedroles == nil {
		m.removedroles = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *MenuMutation) RemovedRolesIDs() (ids []uint32) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *MenuMutation) RolesIDs() (ids []uint32) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *MenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.state != nil {
		fields = append(fields, menu.FieldState)
	}
	if m.sort != nil {
		fields = append(fields, menu.FieldSort)
	}
	if m.menu_code != nil {
		fields = append(fields, menu.FieldMenuCode)
	}
	if m.menu_name != nil {
		fields = append(fields, menu.FieldMenuName)
	}
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m.menu_path != nil {
		fields = append(fields, menu.FieldMenuPath)
	}
	if m.component != nil {
		fields = append(fields, menu.FieldComponent)
	}
	if m.redirect != nil {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.menu_level != nil {
		fields = append(fields, menu.FieldMenuLevel)
	}
	if m.icon != nil {
		fields = append(fields, menu.FieldIcon)
	}
	if m.permission != nil {
		fields = append(fields, menu.FieldPermission)
	}
	if m.service_name != nil {
		fields = append(fields, menu.FieldServiceName)
	}
	if m.menu_type != nil {
		fields = append(fields, menu.FieldMenuType)
	}
	if m.is_hidden != nil {
		fields = append(fields, menu.FieldIsHidden)
	}
	if m.is_breadcrumb != nil {
		fields = append(fields, menu.FieldIsBreadcrumb)
	}
	if m.is_cache != nil {
		fields = append(fields, menu.FieldIsCache)
	}
	if m.is_tab != nil {
		fields = append(fields, menu.FieldIsTab)
	}
	if m.is_affix != nil {
		fields = append(fields, menu.FieldIsAffix)
	}
	if m.frame_src != nil {
		fields = append(fields, menu.FieldFrameSrc)
	}
	if m.description != nil {
		fields = append(fields, menu.FieldDescription)
	}
	if m.link != nil {
		fields = append(fields, menu.FieldLink)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldState:
		return m.State()
	case menu.FieldSort:
		return m.Sort()
	case menu.FieldMenuCode:
		return m.MenuCode()
	case menu.FieldMenuName:
		return m.MenuName()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldMenuPath:
		return m.MenuPath()
	case menu.FieldComponent:
		return m.Component()
	case menu.FieldRedirect:
		return m.Redirect()
	case menu.FieldMenuLevel:
		return m.MenuLevel()
	case menu.FieldIcon:
		return m.Icon()
	case menu.FieldPermission:
		return m.Permission()
	case menu.FieldServiceName:
		return m.ServiceName()
	case menu.FieldMenuType:
		return m.MenuType()
	case menu.FieldIsHidden:
		return m.IsHidden()
	case menu.FieldIsBreadcrumb:
		return m.IsBreadcrumb()
	case menu.FieldIsCache:
		return m.IsCache()
	case menu.FieldIsTab:
		return m.IsTab()
	case menu.FieldIsAffix:
		return m.IsAffix()
	case menu.FieldFrameSrc:
		return m.FrameSrc()
	case menu.FieldDescription:
		return m.Description()
	case menu.FieldLink:
		return m.Link()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldState:
		return m.OldState(ctx)
	case menu.FieldSort:
		return m.OldSort(ctx)
	case menu.FieldMenuCode:
		return m.OldMenuCode(ctx)
	case menu.FieldMenuName:
		return m.OldMenuName(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldMenuPath:
		return m.OldMenuPath(ctx)
	case menu.FieldComponent:
		return m.OldComponent(ctx)
	case menu.FieldRedirect:
		return m.OldRedirect(ctx)
	case menu.FieldMenuLevel:
		return m.OldMenuLevel(ctx)
	case menu.FieldIcon:
		return m.OldIcon(ctx)
	case menu.FieldPermission:
		return m.OldPermission(ctx)
	case menu.FieldServiceName:
		return m.OldServiceName(ctx)
	case menu.FieldMenuType:
		return m.OldMenuType(ctx)
	case menu.FieldIsHidden:
		return m.OldIsHidden(ctx)
	case menu.FieldIsBreadcrumb:
		return m.OldIsBreadcrumb(ctx)
	case menu.FieldIsCache:
		return m.OldIsCache(ctx)
	case menu.FieldIsTab:
		return m.OldIsTab(ctx)
	case menu.FieldIsAffix:
		return m.OldIsAffix(ctx)
	case menu.FieldFrameSrc:
		return m.OldFrameSrc(ctx)
	case menu.FieldDescription:
		return m.OldDescription(ctx)
	case menu.FieldLink:
		return m.OldLink(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case menu.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case menu.FieldMenuCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuCode(v)
		return nil
	case menu.FieldMenuName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuName(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldMenuPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuPath(v)
		return nil
	case menu.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case menu.FieldRedirect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirect(v)
		return nil
	case menu.FieldMenuLevel:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuLevel(v)
		return nil
	case menu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case menu.FieldPermission:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermission(v)
		return nil
	case menu.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case menu.FieldMenuType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuType(v)
		return nil
	case menu.FieldIsHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHidden(v)
		return nil
	case menu.FieldIsBreadcrumb:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsBreadcrumb(v)
		return nil
	case menu.FieldIsCache:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCache(v)
		return nil
	case menu.FieldIsTab:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTab(v)
		return nil
	case menu.FieldIsAffix:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAffix(v)
		return nil
	case menu.FieldFrameSrc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrameSrc(v)
		return nil
	case menu.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case menu.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, menu.FieldSort)
	}
	if m.addmenu_level != nil {
		fields = append(fields, menu.FieldMenuLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldSort:
		return m.AddedSort()
	case menu.FieldMenuLevel:
		return m.AddedMenuLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case menu.FieldMenuLevel:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMenuLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldState) {
		fields = append(fields, menu.FieldState)
	}
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldMenuPath) {
		fields = append(fields, menu.FieldMenuPath)
	}
	if m.FieldCleared(menu.FieldComponent) {
		fields = append(fields, menu.FieldComponent)
	}
	if m.FieldCleared(menu.FieldRedirect) {
		fields = append(fields, menu.FieldRedirect)
	}
	if m.FieldCleared(menu.FieldIcon) {
		fields = append(fields, menu.FieldIcon)
	}
	if m.FieldCleared(menu.FieldPermission) {
		fields = append(fields, menu.FieldPermission)
	}
	if m.FieldCleared(menu.FieldServiceName) {
		fields = append(fields, menu.FieldServiceName)
	}
	if m.FieldCleared(menu.FieldIsHidden) {
		fields = append(fields, menu.FieldIsHidden)
	}
	if m.FieldCleared(menu.FieldIsBreadcrumb) {
		fields = append(fields, menu.FieldIsBreadcrumb)
	}
	if m.FieldCleared(menu.FieldIsCache) {
		fields = append(fields, menu.FieldIsCache)
	}
	if m.FieldCleared(menu.FieldIsTab) {
		fields = append(fields, menu.FieldIsTab)
	}
	if m.FieldCleared(menu.FieldIsAffix) {
		fields = append(fields, menu.FieldIsAffix)
	}
	if m.FieldCleared(menu.FieldFrameSrc) {
		fields = append(fields, menu.FieldFrameSrc)
	}
	if m.FieldCleared(menu.FieldDescription) {
		fields = append(fields, menu.FieldDescription)
	}
	if m.FieldCleared(menu.FieldLink) {
		fields = append(fields, menu.FieldLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldState:
		m.ClearState()
		return nil
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldMenuPath:
		m.ClearMenuPath()
		return nil
	case menu.FieldComponent:
		m.ClearComponent()
		return nil
	case menu.FieldRedirect:
		m.ClearRedirect()
		return nil
	case menu.FieldIcon:
		m.ClearIcon()
		return nil
	case menu.FieldPermission:
		m.ClearPermission()
		return nil
	case menu.FieldServiceName:
		m.ClearServiceName()
		return nil
	case menu.FieldIsHidden:
		m.ClearIsHidden()
		return nil
	case menu.FieldIsBreadcrumb:
		m.ClearIsBreadcrumb()
		return nil
	case menu.FieldIsCache:
		m.ClearIsCache()
		return nil
	case menu.FieldIsTab:
		m.ClearIsTab()
		return nil
	case menu.FieldIsAffix:
		m.ClearIsAffix()
		return nil
	case menu.FieldFrameSrc:
		m.ClearFrameSrc()
		return nil
	case menu.FieldDescription:
		m.ClearDescription()
		return nil
	case menu.FieldLink:
		m.ClearLink()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldState:
		m.ResetState()
		return nil
	case menu.FieldSort:
		m.ResetSort()
		return nil
	case menu.FieldMenuCode:
		m.ResetMenuCode()
		return nil
	case menu.FieldMenuName:
		m.ResetMenuName()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldMenuPath:
		m.ResetMenuPath()
		return nil
	case menu.FieldComponent:
		m.ResetComponent()
		return nil
	case menu.FieldRedirect:
		m.ResetRedirect()
		return nil
	case menu.FieldMenuLevel:
		m.ResetMenuLevel()
		return nil
	case menu.FieldIcon:
		m.ResetIcon()
		return nil
	case menu.FieldPermission:
		m.ResetPermission()
		return nil
	case menu.FieldServiceName:
		m.ResetServiceName()
		return nil
	case menu.FieldMenuType:
		m.ResetMenuType()
		return nil
	case menu.FieldIsHidden:
		m.ResetIsHidden()
		return nil
	case menu.FieldIsBreadcrumb:
		m.ResetIsBreadcrumb()
		return nil
	case menu.FieldIsCache:
		m.ResetIsCache()
		return nil
	case menu.FieldIsTab:
		m.ResetIsTab()
		return nil
	case menu.FieldIsAffix:
		m.ResetIsAffix()
		return nil
	case menu.FieldFrameSrc:
		m.ResetFrameSrc()
		return nil
	case menu.FieldDescription:
		m.ResetDescription()
		return nil
	case menu.FieldLink:
		m.ResetLink()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.roles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.removedroles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.clearedroles {
		edges = append(edges, menu.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	case menu.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	case menu.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// OauthProviderMutation represents an operation that mutates the OauthProvider nodes in the graph.
type OauthProviderMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	created_at        *time.Time
	updated_at        *time.Time
	state             *bool
	provider_name     *string
	provider_code     *string
	client_id         *string
	client_secret     *string
	redirect_uri      *string
	scopes            *string
	authorization_url *string
	token_url         *string
	userinfo_url      *string
	logout_url        *string
	auth_style        *uint8
	addauth_style     *int8
	clearedFields     map[string]struct{}
	tokens            map[uint32]struct{}
	removedtokens     map[uint32]struct{}
	clearedtokens     bool
	done              bool
	oldValue          func(context.Context) (*OauthProvider, error)
	predicates        []predicate.OauthProvider
}

var _ ent.Mutation = (*OauthProviderMutation)(nil)

// oauthproviderOption allows management of the mutation configuration using functional options.
type oauthproviderOption func(*OauthProviderMutation)

// newOauthProviderMutation creates new mutation for the OauthProvider entity.
func newOauthProviderMutation(c config, op Op, opts ...oauthproviderOption) *OauthProviderMutation {
	m := &OauthProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeOauthProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauthProviderID sets the ID field of the mutation.
func withOauthProviderID(id uint32) oauthproviderOption {
	return func(m *OauthProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *OauthProvider
		)
		m.oldValue = func(ctx context.Context) (*OauthProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OauthProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauthProvider sets the old OauthProvider of the mutation.
func withOauthProvider(node *OauthProvider) oauthproviderOption {
	return func(m *OauthProviderMutation) {
		m.oldValue = func(context.Context) (*OauthProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OauthProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OauthProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OauthProvider entities.
func (m *OauthProviderMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OauthProviderMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OauthProviderMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OauthProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OauthProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OauthProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OauthProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OauthProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OauthProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OauthProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetState sets the "state" field.
func (m *OauthProviderMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *OauthProviderMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *OauthProviderMutation) ClearState() {
	m.state = nil
	m.clearedFields[oauthprovider.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *OauthProviderMutation) StateCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *OauthProviderMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, oauthprovider.FieldState)
}

// SetProviderName sets the "provider_name" field.
func (m *OauthProviderMutation) SetProviderName(s string) {
	m.provider_name = &s
}

// ProviderName returns the value of the "provider_name" field in the mutation.
func (m *OauthProviderMutation) ProviderName() (r string, exists bool) {
	v := m.provider_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderName returns the old "provider_name" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldProviderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderName: %w", err)
	}
	return oldValue.ProviderName, nil
}

// ResetProviderName resets all changes to the "provider_name" field.
func (m *OauthProviderMutation) ResetProviderName() {
	m.provider_name = nil
}

// SetProviderCode sets the "provider_code" field.
func (m *OauthProviderMutation) SetProviderCode(s string) {
	m.provider_code = &s
}

// ProviderCode returns the value of the "provider_code" field in the mutation.
func (m *OauthProviderMutation) ProviderCode() (r string, exists bool) {
	v := m.provider_code
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderCode returns the old "provider_code" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldProviderCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderCode: %w", err)
	}
	return oldValue.ProviderCode, nil
}

// ResetProviderCode resets all changes to the "provider_code" field.
func (m *OauthProviderMutation) ResetProviderCode() {
	m.provider_code = nil
}

// SetClientID sets the "client_id" field.
func (m *OauthProviderMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OauthProviderMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OauthProviderMutation) ResetClientID() {
	m.client_id = nil
}

// SetClientSecret sets the "client_secret" field.
func (m *OauthProviderMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *OauthProviderMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *OauthProviderMutation) ResetClientSecret() {
	m.client_secret = nil
}

// SetRedirectURI sets the "redirect_uri" field.
func (m *OauthProviderMutation) SetRedirectURI(s string) {
	m.redirect_uri = &s
}

// RedirectURI returns the value of the "redirect_uri" field in the mutation.
func (m *OauthProviderMutation) RedirectURI() (r string, exists bool) {
	v := m.redirect_uri
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURI returns the old "redirect_uri" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldRedirectURI(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURI: %w", err)
	}
	return oldValue.RedirectURI, nil
}

// ResetRedirectURI resets all changes to the "redirect_uri" field.
func (m *OauthProviderMutation) ResetRedirectURI() {
	m.redirect_uri = nil
}

// SetScopes sets the "scopes" field.
func (m *OauthProviderMutation) SetScopes(s string) {
	m.scopes = &s
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *OauthProviderMutation) Scopes() (r string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldScopes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// ClearScopes clears the value of the "scopes" field.
func (m *OauthProviderMutation) ClearScopes() {
	m.scopes = nil
	m.clearedFields[oauthprovider.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *OauthProviderMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *OauthProviderMutation) ResetScopes() {
	m.scopes = nil
	delete(m.clearedFields, oauthprovider.FieldScopes)
}

// SetAuthorizationURL sets the "authorization_url" field.
func (m *OauthProviderMutation) SetAuthorizationURL(s string) {
	m.authorization_url = &s
}

// AuthorizationURL returns the value of the "authorization_url" field in the mutation.
func (m *OauthProviderMutation) AuthorizationURL() (r string, exists bool) {
	v := m.authorization_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorizationURL returns the old "authorization_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldAuthorizationURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorizationURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorizationURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorizationURL: %w", err)
	}
	return oldValue.AuthorizationURL, nil
}

// ResetAuthorizationURL resets all changes to the "authorization_url" field.
func (m *OauthProviderMutation) ResetAuthorizationURL() {
	m.authorization_url = nil
}

// SetTokenURL sets the "token_url" field.
func (m *OauthProviderMutation) SetTokenURL(s string) {
	m.token_url = &s
}

// TokenURL returns the value of the "token_url" field in the mutation.
func (m *OauthProviderMutation) TokenURL() (r string, exists bool) {
	v := m.token_url
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenURL returns the old "token_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldTokenURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenURL: %w", err)
	}
	return oldValue.TokenURL, nil
}

// ResetTokenURL resets all changes to the "token_url" field.
func (m *OauthProviderMutation) ResetTokenURL() {
	m.token_url = nil
}

// SetUserinfoURL sets the "userinfo_url" field.
func (m *OauthProviderMutation) SetUserinfoURL(s string) {
	m.userinfo_url = &s
}

// UserinfoURL returns the value of the "userinfo_url" field in the mutation.
func (m *OauthProviderMutation) UserinfoURL() (r string, exists bool) {
	v := m.userinfo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldUserinfoURL returns the old "userinfo_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldUserinfoURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserinfoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserinfoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserinfoURL: %w", err)
	}
	return oldValue.UserinfoURL, nil
}

// ClearUserinfoURL clears the value of the "userinfo_url" field.
func (m *OauthProviderMutation) ClearUserinfoURL() {
	m.userinfo_url = nil
	m.clearedFields[oauthprovider.FieldUserinfoURL] = struct{}{}
}

// UserinfoURLCleared returns if the "userinfo_url" field was cleared in this mutation.
func (m *OauthProviderMutation) UserinfoURLCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldUserinfoURL]
	return ok
}

// ResetUserinfoURL resets all changes to the "userinfo_url" field.
func (m *OauthProviderMutation) ResetUserinfoURL() {
	m.userinfo_url = nil
	delete(m.clearedFields, oauthprovider.FieldUserinfoURL)
}

// SetLogoutURL sets the "logout_url" field.
func (m *OauthProviderMutation) SetLogoutURL(s string) {
	m.logout_url = &s
}

// LogoutURL returns the value of the "logout_url" field in the mutation.
func (m *OauthProviderMutation) LogoutURL() (r string, exists bool) {
	v := m.logout_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoutURL returns the old "logout_url" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldLogoutURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoutURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoutURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoutURL: %w", err)
	}
	return oldValue.LogoutURL, nil
}

// ClearLogoutURL clears the value of the "logout_url" field.
func (m *OauthProviderMutation) ClearLogoutURL() {
	m.logout_url = nil
	m.clearedFields[oauthprovider.FieldLogoutURL] = struct{}{}
}

// LogoutURLCleared returns if the "logout_url" field was cleared in this mutation.
func (m *OauthProviderMutation) LogoutURLCleared() bool {
	_, ok := m.clearedFields[oauthprovider.FieldLogoutURL]
	return ok
}

// ResetLogoutURL resets all changes to the "logout_url" field.
func (m *OauthProviderMutation) ResetLogoutURL() {
	m.logout_url = nil
	delete(m.clearedFields, oauthprovider.FieldLogoutURL)
}

// SetAuthStyle sets the "auth_style" field.
func (m *OauthProviderMutation) SetAuthStyle(u uint8) {
	m.auth_style = &u
	m.addauth_style = nil
}

// AuthStyle returns the value of the "auth_style" field in the mutation.
func (m *OauthProviderMutation) AuthStyle() (r uint8, exists bool) {
	v := m.auth_style
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthStyle returns the old "auth_style" field's value of the OauthProvider entity.
// If the OauthProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthProviderMutation) OldAuthStyle(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthStyle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthStyle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthStyle: %w", err)
	}
	return oldValue.AuthStyle, nil
}

// AddAuthStyle adds u to the "auth_style" field.
func (m *OauthProviderMutation) AddAuthStyle(u int8) {
	if m.addauth_style != nil {
		*m.addauth_style += u
	} else {
		m.addauth_style = &u
	}
}

// AddedAuthStyle returns the value that was added to the "auth_style" field in this mutation.
func (m *OauthProviderMutation) AddedAuthStyle() (r int8, exists bool) {
	v := m.addauth_style
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthStyle resets all changes to the "auth_style" field.
func (m *OauthProviderMutation) ResetAuthStyle() {
	m.auth_style = nil
	m.addauth_style = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *OauthProviderMutation) AddTokenIDs(ids ...uint32) {
	if m.tokens == nil {
		m.tokens = make(map[uint32]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *OauthProviderMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *OauthProviderMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *OauthProviderMutation) RemoveTokenIDs(ids ...uint32) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *OauthProviderMutation) RemovedTokensIDs() (ids []uint32) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *OauthProviderMutation) TokensIDs() (ids []uint32) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *OauthProviderMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// Where appends a list predicates to the OauthProviderMutation builder.
func (m *OauthProviderMutation) Where(ps ...predicate.OauthProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OauthProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OauthProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OauthProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OauthProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OauthProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OauthProvider).
func (m *OauthProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OauthProviderMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, oauthprovider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthprovider.FieldUpdatedAt)
	}
	if m.state != nil {
		fields = append(fields, oauthprovider.FieldState)
	}
	if m.provider_name != nil {
		fields = append(fields, oauthprovider.FieldProviderName)
	}
	if m.provider_code != nil {
		fields = append(fields, oauthprovider.FieldProviderCode)
	}
	if m.client_id != nil {
		fields = append(fields, oauthprovider.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, oauthprovider.FieldClientSecret)
	}
	if m.redirect_uri != nil {
		fields = append(fields, oauthprovider.FieldRedirectURI)
	}
	if m.scopes != nil {
		fields = append(fields, oauthprovider.FieldScopes)
	}
	if m.authorization_url != nil {
		fields = append(fields, oauthprovider.FieldAuthorizationURL)
	}
	if m.token_url != nil {
		fields = append(fields, oauthprovider.FieldTokenURL)
	}
	if m.userinfo_url != nil {
		fields = append(fields, oauthprovider.FieldUserinfoURL)
	}
	if m.logout_url != nil {
		fields = append(fields, oauthprovider.FieldLogoutURL)
	}
	if m.auth_style != nil {
		fields = append(fields, oauthprovider.FieldAuthStyle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OauthProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthprovider.FieldCreatedAt:
		return m.CreatedAt()
	case oauthprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthprovider.FieldState:
		return m.State()
	case oauthprovider.FieldProviderName:
		return m.ProviderName()
	case oauthprovider.FieldProviderCode:
		return m.ProviderCode()
	case oauthprovider.FieldClientID:
		return m.ClientID()
	case oauthprovider.FieldClientSecret:
		return m.ClientSecret()
	case oauthprovider.FieldRedirectURI:
		return m.RedirectURI()
	case oauthprovider.FieldScopes:
		return m.Scopes()
	case oauthprovider.FieldAuthorizationURL:
		return m.AuthorizationURL()
	case oauthprovider.FieldTokenURL:
		return m.TokenURL()
	case oauthprovider.FieldUserinfoURL:
		return m.UserinfoURL()
	case oauthprovider.FieldLogoutURL:
		return m.LogoutURL()
	case oauthprovider.FieldAuthStyle:
		return m.AuthStyle()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OauthProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthprovider.FieldState:
		return m.OldState(ctx)
	case oauthprovider.FieldProviderName:
		return m.OldProviderName(ctx)
	case oauthprovider.FieldProviderCode:
		return m.OldProviderCode(ctx)
	case oauthprovider.FieldClientID:
		return m.OldClientID(ctx)
	case oauthprovider.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case oauthprovider.FieldRedirectURI:
		return m.OldRedirectURI(ctx)
	case oauthprovider.FieldScopes:
		return m.OldScopes(ctx)
	case oauthprovider.FieldAuthorizationURL:
		return m.OldAuthorizationURL(ctx)
	case oauthprovider.FieldTokenURL:
		return m.OldTokenURL(ctx)
	case oauthprovider.FieldUserinfoURL:
		return m.OldUserinfoURL(ctx)
	case oauthprovider.FieldLogoutURL:
		return m.OldLogoutURL(ctx)
	case oauthprovider.FieldAuthStyle:
		return m.OldAuthStyle(ctx)
	}
	return nil, fmt.Errorf("unknown OauthProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthprovider.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case oauthprovider.FieldProviderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderName(v)
		return nil
	case oauthprovider.FieldProviderCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderCode(v)
		return nil
	case oauthprovider.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthprovider.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case oauthprovider.FieldRedirectURI:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURI(v)
		return nil
	case oauthprovider.FieldScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case oauthprovider.FieldAuthorizationURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorizationURL(v)
		return nil
	case oauthprovider.FieldTokenURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenURL(v)
		return nil
	case oauthprovider.FieldUserinfoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserinfoURL(v)
		return nil
	case oauthprovider.FieldLogoutURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoutURL(v)
		return nil
	case oauthprovider.FieldAuthStyle:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthStyle(v)
		return nil
	}
	return fmt.Errorf("unknown OauthProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OauthProviderMutation) AddedFields() []string {
	var fields []string
	if m.addauth_style != nil {
		fields = append(fields, oauthprovider.FieldAuthStyle)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OauthProviderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case oauthprovider.FieldAuthStyle:
		return m.AddedAuthStyle()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case oauthprovider.FieldAuthStyle:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthStyle(v)
		return nil
	}
	return fmt.Errorf("unknown OauthProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OauthProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthprovider.FieldState) {
		fields = append(fields, oauthprovider.FieldState)
	}
	if m.FieldCleared(oauthprovider.FieldScopes) {
		fields = append(fields, oauthprovider.FieldScopes)
	}
	if m.FieldCleared(oauthprovider.FieldUserinfoURL) {
		fields = append(fields, oauthprovider.FieldUserinfoURL)
	}
	if m.FieldCleared(oauthprovider.FieldLogoutURL) {
		fields = append(fields, oauthprovider.FieldLogoutURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OauthProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OauthProviderMutation) ClearField(name string) error {
	switch name {
	case oauthprovider.FieldState:
		m.ClearState()
		return nil
	case oauthprovider.FieldScopes:
		m.ClearScopes()
		return nil
	case oauthprovider.FieldUserinfoURL:
		m.ClearUserinfoURL()
		return nil
	case oauthprovider.FieldLogoutURL:
		m.ClearLogoutURL()
		return nil
	}
	return fmt.Errorf("unknown OauthProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OauthProviderMutation) ResetField(name string) error {
	switch name {
	case oauthprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthprovider.FieldState:
		m.ResetState()
		return nil
	case oauthprovider.FieldProviderName:
		m.ResetProviderName()
		return nil
	case oauthprovider.FieldProviderCode:
		m.ResetProviderCode()
		return nil
	case oauthprovider.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthprovider.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case oauthprovider.FieldRedirectURI:
		m.ResetRedirectURI()
		return nil
	case oauthprovider.FieldScopes:
		m.ResetScopes()
		return nil
	case oauthprovider.FieldAuthorizationURL:
		m.ResetAuthorizationURL()
		return nil
	case oauthprovider.FieldTokenURL:
		m.ResetTokenURL()
		return nil
	case oauthprovider.FieldUserinfoURL:
		m.ResetUserinfoURL()
		return nil
	case oauthprovider.FieldLogoutURL:
		m.ResetLogoutURL()
		return nil
	case oauthprovider.FieldAuthStyle:
		m.ResetAuthStyle()
		return nil
	}
	return fmt.Errorf("unknown OauthProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OauthProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tokens != nil {
		edges = append(edges, oauthprovider.EdgeTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OauthProviderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case oauthprovider.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OauthProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtokens != nil {
		edges = append(edges, oauthprovider.EdgeTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OauthProviderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case oauthprovider.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OauthProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtokens {
		edges = append(edges, oauthprovider.EdgeTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OauthProviderMutation) EdgeCleared(name string) bool {
	switch name {
	case oauthprovider.EdgeTokens:
		return m.clearedtokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OauthProviderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OauthProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OauthProviderMutation) ResetEdge(name string) error {
	switch name {
	case oauthprovider.EdgeTokens:
		m.ResetTokens()
		return nil
	}
	return fmt.Errorf("unknown OauthProvider edge %s", name)
}

// OperationLogMutation represents an operation that mutates the OperationLog nodes in the graph.
type OperationLogMutation struct {
	config
	op                Op
	typ               string
	id                *uint32
	created_at        *time.Time
	updated_at        *time.Time
	username          *string
	operation_type    *string
	module            *string
	business_type     *string
	method            *string
	request_url       *string
	request_params    *string
	response_data     *string
	ip_address        *string
	user_agent        *string
	location          *string
	is_success        *bool
	error_message     *string
	execution_time    *int
	addexecution_time *int
	description       *string
	clearedFields     map[string]struct{}
	user              *uuid.UUID
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*OperationLog, error)
	predicates        []predicate.OperationLog
}

var _ ent.Mutation = (*OperationLogMutation)(nil)

// operationlogOption allows management of the mutation configuration using functional options.
type operationlogOption func(*OperationLogMutation)

// newOperationLogMutation creates new mutation for the OperationLog entity.
func newOperationLogMutation(c config, op Op, opts ...operationlogOption) *OperationLogMutation {
	m := &OperationLogMutation{
		config:        c,
		op:            op,
		typ:           TypeOperationLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperationLogID sets the ID field of the mutation.
func withOperationLogID(id uint32) operationlogOption {
	return func(m *OperationLogMutation) {
		var (
			err   error
			once  sync.Once
			value *OperationLog
		)
		m.oldValue = func(ctx context.Context) (*OperationLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OperationLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperationLog sets the old OperationLog of the mutation.
func withOperationLog(node *OperationLog) operationlogOption {
	return func(m *OperationLogMutation) {
		m.oldValue = func(context.Context) (*OperationLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperationLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperationLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OperationLog entities.
func (m *OperationLogMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OperationLogMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OperationLogMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OperationLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OperationLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OperationLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OperationLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OperationLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OperationLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OperationLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *OperationLogMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OperationLogMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldUserID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *OperationLogMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[operationlog.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *OperationLogMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OperationLogMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, operationlog.FieldUserID)
}

// SetUsername sets the "username" field.
func (m *OperationLogMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *OperationLogMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *OperationLogMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[operationlog.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *OperationLogMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *OperationLogMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, operationlog.FieldUsername)
}

// SetOperationType sets the "operation_type" field.
func (m *OperationLogMutation) SetOperationType(s string) {
	m.operation_type = &s
}

// OperationType returns the value of the "operation_type" field in the mutation.
func (m *OperationLogMutation) OperationType() (r string, exists bool) {
	v := m.operation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOperationType returns the old "operation_type" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldOperationType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperationType: %w", err)
	}
	return oldValue.OperationType, nil
}

// ResetOperationType resets all changes to the "operation_type" field.
func (m *OperationLogMutation) ResetOperationType() {
	m.operation_type = nil
}

// SetModule sets the "module" field.
func (m *OperationLogMutation) SetModule(s string) {
	m.module = &s
}

// Module returns the value of the "module" field in the mutation.
func (m *OperationLogMutation) Module() (r string, exists bool) {
	v := m.module
	if v == nil {
		return
	}
	return *v, true
}

// OldModule returns the old "module" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldModule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModule: %w", err)
	}
	return oldValue.Module, nil
}

// ResetModule resets all changes to the "module" field.
func (m *OperationLogMutation) ResetModule() {
	m.module = nil
}

// SetBusinessType sets the "business_type" field.
func (m *OperationLogMutation) SetBusinessType(s string) {
	m.business_type = &s
}

// BusinessType returns the value of the "business_type" field in the mutation.
func (m *OperationLogMutation) BusinessType() (r string, exists bool) {
	v := m.business_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessType returns the old "business_type" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldBusinessType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessType: %w", err)
	}
	return oldValue.BusinessType, nil
}

// ClearBusinessType clears the value of the "business_type" field.
func (m *OperationLogMutation) ClearBusinessType() {
	m.business_type = nil
	m.clearedFields[operationlog.FieldBusinessType] = struct{}{}
}

// BusinessTypeCleared returns if the "business_type" field was cleared in this mutation.
func (m *OperationLogMutation) BusinessTypeCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldBusinessType]
	return ok
}

// ResetBusinessType resets all changes to the "business_type" field.
func (m *OperationLogMutation) ResetBusinessType() {
	m.business_type = nil
	delete(m.clearedFields, operationlog.FieldBusinessType)
}

// SetMethod sets the "method" field.
func (m *OperationLogMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *OperationLogMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldMethod(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *OperationLogMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[operationlog.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *OperationLogMutation) MethodCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *OperationLogMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, operationlog.FieldMethod)
}

// SetRequestURL sets the "request_url" field.
func (m *OperationLogMutation) SetRequestURL(s string) {
	m.request_url = &s
}

// RequestURL returns the value of the "request_url" field in the mutation.
func (m *OperationLogMutation) RequestURL() (r string, exists bool) {
	v := m.request_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestURL returns the old "request_url" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldRequestURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestURL: %w", err)
	}
	return oldValue.RequestURL, nil
}

// ClearRequestURL clears the value of the "request_url" field.
func (m *OperationLogMutation) ClearRequestURL() {
	m.request_url = nil
	m.clearedFields[operationlog.FieldRequestURL] = struct{}{}
}

// RequestURLCleared returns if the "request_url" field was cleared in this mutation.
func (m *OperationLogMutation) RequestURLCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldRequestURL]
	return ok
}

// ResetRequestURL resets all changes to the "request_url" field.
func (m *OperationLogMutation) ResetRequestURL() {
	m.request_url = nil
	delete(m.clearedFields, operationlog.FieldRequestURL)
}

// SetRequestParams sets the "request_params" field.
func (m *OperationLogMutation) SetRequestParams(s string) {
	m.request_params = &s
}

// RequestParams returns the value of the "request_params" field in the mutation.
func (m *OperationLogMutation) RequestParams() (r string, exists bool) {
	v := m.request_params
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestParams returns the old "request_params" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldRequestParams(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestParams: %w", err)
	}
	return oldValue.RequestParams, nil
}

// ClearRequestParams clears the value of the "request_params" field.
func (m *OperationLogMutation) ClearRequestParams() {
	m.request_params = nil
	m.clearedFields[operationlog.FieldRequestParams] = struct{}{}
}

// RequestParamsCleared returns if the "request_params" field was cleared in this mutation.
func (m *OperationLogMutation) RequestParamsCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldRequestParams]
	return ok
}

// ResetRequestParams resets all changes to the "request_params" field.
func (m *OperationLogMutation) ResetRequestParams() {
	m.request_params = nil
	delete(m.clearedFields, operationlog.FieldRequestParams)
}

// SetResponseData sets the "response_data" field.
func (m *OperationLogMutation) SetResponseData(s string) {
	m.response_data = &s
}

// ResponseData returns the value of the "response_data" field in the mutation.
func (m *OperationLogMutation) ResponseData() (r string, exists bool) {
	v := m.response_data
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseData returns the old "response_data" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldResponseData(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseData: %w", err)
	}
	return oldValue.ResponseData, nil
}

// ClearResponseData clears the value of the "response_data" field.
func (m *OperationLogMutation) ClearResponseData() {
	m.response_data = nil
	m.clearedFields[operationlog.FieldResponseData] = struct{}{}
}

// ResponseDataCleared returns if the "response_data" field was cleared in this mutation.
func (m *OperationLogMutation) ResponseDataCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldResponseData]
	return ok
}

// ResetResponseData resets all changes to the "response_data" field.
func (m *OperationLogMutation) ResetResponseData() {
	m.response_data = nil
	delete(m.clearedFields, operationlog.FieldResponseData)
}

// SetIPAddress sets the "ip_address" field.
func (m *OperationLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *OperationLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *OperationLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[operationlog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *OperationLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *OperationLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, operationlog.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *OperationLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *OperationLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *OperationLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[operationlog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *OperationLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *OperationLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, operationlog.FieldUserAgent)
}

// SetLocation sets the "location" field.
func (m *OperationLogMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *OperationLogMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldLocation(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *OperationLogMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[operationlog.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *OperationLogMutation) LocationCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *OperationLogMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, operationlog.FieldLocation)
}

// SetIsSuccess sets the "is_success" field.
func (m *OperationLogMutation) SetIsSuccess(b bool) {
	m.is_success = &b
}

// IsSuccess returns the value of the "is_success" field in the mutation.
func (m *OperationLogMutation) IsSuccess() (r bool, exists bool) {
	v := m.is_success
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuccess returns the old "is_success" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldIsSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuccess: %w", err)
	}
	return oldValue.IsSuccess, nil
}

// ResetIsSuccess resets all changes to the "is_success" field.
func (m *OperationLogMutation) ResetIsSuccess() {
	m.is_success = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *OperationLogMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *OperationLogMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *OperationLogMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[operationlog.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *OperationLogMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *OperationLogMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, operationlog.FieldErrorMessage)
}

// SetExecutionTime sets the "execution_time" field.
func (m *OperationLogMutation) SetExecutionTime(i int) {
	m.execution_time = &i
	m.addexecution_time = nil
}

// ExecutionTime returns the value of the "execution_time" field in the mutation.
func (m *OperationLogMutation) ExecutionTime() (r int, exists bool) {
	v := m.execution_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutionTime returns the old "execution_time" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldExecutionTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutionTime: %w", err)
	}
	return oldValue.ExecutionTime, nil
}

// AddExecutionTime adds i to the "execution_time" field.
func (m *OperationLogMutation) AddExecutionTime(i int) {
	if m.addexecution_time != nil {
		*m.addexecution_time += i
	} else {
		m.addexecution_time = &i
	}
}

// AddedExecutionTime returns the value that was added to the "execution_time" field in this mutation.
func (m *OperationLogMutation) AddedExecutionTime() (r int, exists bool) {
	v := m.addexecution_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetExecutionTime resets all changes to the "execution_time" field.
func (m *OperationLogMutation) ResetExecutionTime() {
	m.execution_time = nil
	m.addexecution_time = nil
}

// SetDescription sets the "description" field.
func (m *OperationLogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OperationLogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OperationLog entity.
// If the OperationLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OperationLogMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *OperationLogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[operationlog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *OperationLogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[operationlog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *OperationLogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, operationlog.FieldDescription)
}

// ClearUser clears the "user" edge to the User entity.
func (m *OperationLogMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[operationlog.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OperationLogMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OperationLogMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OperationLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the OperationLogMutation builder.
func (m *OperationLogMutation) Where(ps ...predicate.OperationLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OperationLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OperationLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OperationLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OperationLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OperationLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OperationLog).
func (m *OperationLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OperationLogMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, operationlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, operationlog.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, operationlog.FieldUserID)
	}
	if m.username != nil {
		fields = append(fields, operationlog.FieldUsername)
	}
	if m.operation_type != nil {
		fields = append(fields, operationlog.FieldOperationType)
	}
	if m.module != nil {
		fields = append(fields, operationlog.FieldModule)
	}
	if m.business_type != nil {
		fields = append(fields, operationlog.FieldBusinessType)
	}
	if m.method != nil {
		fields = append(fields, operationlog.FieldMethod)
	}
	if m.request_url != nil {
		fields = append(fields, operationlog.FieldRequestURL)
	}
	if m.request_params != nil {
		fields = append(fields, operationlog.FieldRequestParams)
	}
	if m.response_data != nil {
		fields = append(fields, operationlog.FieldResponseData)
	}
	if m.ip_address != nil {
		fields = append(fields, operationlog.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, operationlog.FieldUserAgent)
	}
	if m.location != nil {
		fields = append(fields, operationlog.FieldLocation)
	}
	if m.is_success != nil {
		fields = append(fields, operationlog.FieldIsSuccess)
	}
	if m.error_message != nil {
		fields = append(fields, operationlog.FieldErrorMessage)
	}
	if m.execution_time != nil {
		fields = append(fields, operationlog.FieldExecutionTime)
	}
	if m.description != nil {
		fields = append(fields, operationlog.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OperationLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operationlog.FieldCreatedAt:
		return m.CreatedAt()
	case operationlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case operationlog.FieldUserID:
		return m.UserID()
	case operationlog.FieldUsername:
		return m.Username()
	case operationlog.FieldOperationType:
		return m.OperationType()
	case operationlog.FieldModule:
		return m.Module()
	case operationlog.FieldBusinessType:
		return m.BusinessType()
	case operationlog.FieldMethod:
		return m.Method()
	case operationlog.FieldRequestURL:
		return m.RequestURL()
	case operationlog.FieldRequestParams:
		return m.RequestParams()
	case operationlog.FieldResponseData:
		return m.ResponseData()
	case operationlog.FieldIPAddress:
		return m.IPAddress()
	case operationlog.FieldUserAgent:
		return m.UserAgent()
	case operationlog.FieldLocation:
		return m.Location()
	case operationlog.FieldIsSuccess:
		return m.IsSuccess()
	case operationlog.FieldErrorMessage:
		return m.ErrorMessage()
	case operationlog.FieldExecutionTime:
		return m.ExecutionTime()
	case operationlog.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OperationLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operationlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case operationlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case operationlog.FieldUserID:
		return m.OldUserID(ctx)
	case operationlog.FieldUsername:
		return m.OldUsername(ctx)
	case operationlog.FieldOperationType:
		return m.OldOperationType(ctx)
	case operationlog.FieldModule:
		return m.OldModule(ctx)
	case operationlog.FieldBusinessType:
		return m.OldBusinessType(ctx)
	case operationlog.FieldMethod:
		return m.OldMethod(ctx)
	case operationlog.FieldRequestURL:
		return m.OldRequestURL(ctx)
	case operationlog.FieldRequestParams:
		return m.OldRequestParams(ctx)
	case operationlog.FieldResponseData:
		return m.OldResponseData(ctx)
	case operationlog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case operationlog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case operationlog.FieldLocation:
		return m.OldLocation(ctx)
	case operationlog.FieldIsSuccess:
		return m.OldIsSuccess(ctx)
	case operationlog.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case operationlog.FieldExecutionTime:
		return m.OldExecutionTime(ctx)
	case operationlog.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown OperationLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperationLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operationlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case operationlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case operationlog.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case operationlog.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case operationlog.FieldOperationType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperationType(v)
		return nil
	case operationlog.FieldModule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModule(v)
		return nil
	case operationlog.FieldBusinessType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessType(v)
		return nil
	case operationlog.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case operationlog.FieldRequestURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestURL(v)
		return nil
	case operationlog.FieldRequestParams:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestParams(v)
		return nil
	case operationlog.FieldResponseData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseData(v)
		return nil
	case operationlog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case operationlog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case operationlog.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case operationlog.FieldIsSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuccess(v)
		return nil
	case operationlog.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case operationlog.FieldExecutionTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutionTime(v)
		return nil
	case operationlog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown OperationLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OperationLogMutation) AddedFields() []string {
	var fields []string
	if m.addexecution_time != nil {
		fields = append(fields, operationlog.FieldExecutionTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OperationLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case operationlog.FieldExecutionTime:
		return m.AddedExecutionTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OperationLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case operationlog.FieldExecutionTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutionTime(v)
		return nil
	}
	return fmt.Errorf("unknown OperationLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OperationLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(operationlog.FieldUserID) {
		fields = append(fields, operationlog.FieldUserID)
	}
	if m.FieldCleared(operationlog.FieldUsername) {
		fields = append(fields, operationlog.FieldUsername)
	}
	if m.FieldCleared(operationlog.FieldBusinessType) {
		fields = append(fields, operationlog.FieldBusinessType)
	}
	if m.FieldCleared(operationlog.FieldMethod) {
		fields = append(fields, operationlog.FieldMethod)
	}
	if m.FieldCleared(operationlog.FieldRequestURL) {
		fields = append(fields, operationlog.FieldRequestURL)
	}
	if m.FieldCleared(operationlog.FieldRequestParams) {
		fields = append(fields, operationlog.FieldRequestParams)
	}
	if m.FieldCleared(operationlog.FieldResponseData) {
		fields = append(fields, operationlog.FieldResponseData)
	}
	if m.FieldCleared(operationlog.FieldIPAddress) {
		fields = append(fields, operationlog.FieldIPAddress)
	}
	if m.FieldCleared(operationlog.FieldUserAgent) {
		fields = append(fields, operationlog.FieldUserAgent)
	}
	if m.FieldCleared(operationlog.FieldLocation) {
		fields = append(fields, operationlog.FieldLocation)
	}
	if m.FieldCleared(operationlog.FieldErrorMessage) {
		fields = append(fields, operationlog.FieldErrorMessage)
	}
	if m.FieldCleared(operationlog.FieldDescription) {
		fields = append(fields, operationlog.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OperationLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperationLogMutation) ClearField(name string) error {
	switch name {
	case operationlog.FieldUserID:
		m.ClearUserID()
		return nil
	case operationlog.FieldUsername:
		m.ClearUsername()
		return nil
	case operationlog.FieldBusinessType:
		m.ClearBusinessType()
		return nil
	case operationlog.FieldMethod:
		m.ClearMethod()
		return nil
	case operationlog.FieldRequestURL:
		m.ClearRequestURL()
		return nil
	case operationlog.FieldRequestParams:
		m.ClearRequestParams()
		return nil
	case operationlog.FieldResponseData:
		m.ClearResponseData()
		return nil
	case operationlog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case operationlog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case operationlog.FieldLocation:
		m.ClearLocation()
		return nil
	case operationlog.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case operationlog.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown OperationLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OperationLogMutation) ResetField(name string) error {
	switch name {
	case operationlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case operationlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case operationlog.FieldUserID:
		m.ResetUserID()
		return nil
	case operationlog.FieldUsername:
		m.ResetUsername()
		return nil
	case operationlog.FieldOperationType:
		m.ResetOperationType()
		return nil
	case operationlog.FieldModule:
		m.ResetModule()
		return nil
	case operationlog.FieldBusinessType:
		m.ResetBusinessType()
		return nil
	case operationlog.FieldMethod:
		m.ResetMethod()
		return nil
	case operationlog.FieldRequestURL:
		m.ResetRequestURL()
		return nil
	case operationlog.FieldRequestParams:
		m.ResetRequestParams()
		return nil
	case operationlog.FieldResponseData:
		m.ResetResponseData()
		return nil
	case operationlog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case operationlog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case operationlog.FieldLocation:
		m.ResetLocation()
		return nil
	case operationlog.FieldIsSuccess:
		m.ResetIsSuccess()
		return nil
	case operationlog.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case operationlog.FieldExecutionTime:
		m.ResetExecutionTime()
		return nil
	case operationlog.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown OperationLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OperationLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, operationlog.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OperationLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operationlog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OperationLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OperationLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OperationLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, operationlog.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OperationLogMutation) EdgeCleared(name string) bool {
	switch name {
	case operationlog.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OperationLogMutation) ClearEdge(name string) error {
	switch name {
	case operationlog.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown OperationLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OperationLogMutation) ResetEdge(name string) error {
	switch name {
	case operationlog.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown OperationLog edge %s", name)
}

// PositionMutation represents an operation that mutates the Position nodes in the graph.
type PositionMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	state         *bool
	sort          *int32
	addsort       *int32
	position_name *string
	position_code *string
	description   *string
	clearedFields map[string]struct{}
	users         map[uuid.UUID]struct{}
	removedusers  map[uuid.UUID]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Position, error)
	predicates    []predicate.Position
}

var _ ent.Mutation = (*PositionMutation)(nil)

// positionOption allows management of the mutation configuration using functional options.
type positionOption func(*PositionMutation)

// newPositionMutation creates new mutation for the Position entity.
func newPositionMutation(c config, op Op, opts ...positionOption) *PositionMutation {
	m := &PositionMutation{
		config:        c,
		op:            op,
		typ:           TypePosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionID sets the ID field of the mutation.
func withPositionID(id uint32) positionOption {
	return func(m *PositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Position
		)
		m.oldValue = func(ctx context.Context) (*Position, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPosition sets the old Position of the mutation.
func withPosition(node *Position) positionOption {
	return func(m *PositionMutation) {
		m.oldValue = func(context.Context) (*Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Position entities.
func (m *PositionMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Position.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PositionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PositionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PositionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PositionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PositionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PositionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PositionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PositionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PositionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[position.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PositionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[position.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PositionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, position.FieldDeletedAt)
}

// SetState sets the "state" field.
func (m *PositionMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *PositionMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *PositionMutation) ClearState() {
	m.state = nil
	m.clearedFields[position.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *PositionMutation) StateCleared() bool {
	_, ok := m.clearedFields[position.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *PositionMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, position.FieldState)
}

// SetSort sets the "sort" field.
func (m *PositionMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *PositionMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *PositionMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *PositionMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *PositionMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetPositionName sets the "position_name" field.
func (m *PositionMutation) SetPositionName(s string) {
	m.position_name = &s
}

// PositionName returns the value of the "position_name" field in the mutation.
func (m *PositionMutation) PositionName() (r string, exists bool) {
	v := m.position_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionName returns the old "position_name" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldPositionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionName: %w", err)
	}
	return oldValue.PositionName, nil
}

// ResetPositionName resets all changes to the "position_name" field.
func (m *PositionMutation) ResetPositionName() {
	m.position_name = nil
}

// SetPositionCode sets the "position_code" field.
func (m *PositionMutation) SetPositionCode(s string) {
	m.position_code = &s
}

// PositionCode returns the value of the "position_code" field in the mutation.
func (m *PositionMutation) PositionCode() (r string, exists bool) {
	v := m.position_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionCode returns the old "position_code" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldPositionCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionCode: %w", err)
	}
	return oldValue.PositionCode, nil
}

// ResetPositionCode resets all changes to the "position_code" field.
func (m *PositionMutation) ResetPositionCode() {
	m.position_code = nil
}

// SetDescription sets the "description" field.
func (m *PositionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PositionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PositionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[position.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PositionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[position.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PositionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, position.FieldDescription)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *PositionMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *PositionMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *PositionMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *PositionMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *PositionMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *PositionMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *PositionMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the PositionMutation builder.
func (m *PositionMutation) Where(ps ...predicate.Position) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Position, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Position).
func (m *PositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, position.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, position.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, position.FieldDeletedAt)
	}
	if m.state != nil {
		fields = append(fields, position.FieldState)
	}
	if m.sort != nil {
		fields = append(fields, position.FieldSort)
	}
	if m.position_name != nil {
		fields = append(fields, position.FieldPositionName)
	}
	if m.position_code != nil {
		fields = append(fields, position.FieldPositionCode)
	}
	if m.description != nil {
		fields = append(fields, position.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case position.FieldCreatedAt:
		return m.CreatedAt()
	case position.FieldUpdatedAt:
		return m.UpdatedAt()
	case position.FieldDeletedAt:
		return m.DeletedAt()
	case position.FieldState:
		return m.State()
	case position.FieldSort:
		return m.Sort()
	case position.FieldPositionName:
		return m.PositionName()
	case position.FieldPositionCode:
		return m.PositionCode()
	case position.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case position.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case position.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case position.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case position.FieldState:
		return m.OldState(ctx)
	case position.FieldSort:
		return m.OldSort(ctx)
	case position.FieldPositionName:
		return m.OldPositionName(ctx)
	case position.FieldPositionCode:
		return m.OldPositionCode(ctx)
	case position.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Position field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case position.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case position.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case position.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case position.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case position.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case position.FieldPositionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionName(v)
		return nil
	case position.FieldPositionCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionCode(v)
		return nil
	case position.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, position.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case position.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case position.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(position.FieldDeletedAt) {
		fields = append(fields, position.FieldDeletedAt)
	}
	if m.FieldCleared(position.FieldState) {
		fields = append(fields, position.FieldState)
	}
	if m.FieldCleared(position.FieldDescription) {
		fields = append(fields, position.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionMutation) ClearField(name string) error {
	switch name {
	case position.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case position.FieldState:
		m.ClearState()
		return nil
	case position.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Position nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionMutation) ResetField(name string) error {
	switch name {
	case position.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case position.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case position.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case position.FieldState:
		m.ResetState()
		return nil
	case position.FieldSort:
		m.ResetSort()
		return nil
	case position.FieldPositionName:
		m.ResetPositionName()
		return nil
	case position.FieldPositionCode:
		m.ResetPositionCode()
		return nil
	case position.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, position.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusers != nil {
		edges = append(edges, position.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, position.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionMutation) EdgeCleared(name string) bool {
	switch name {
	case position.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Position unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionMutation) ResetEdge(name string) error {
	switch name {
	case position.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Position edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op            Op
	typ           string
	id            *uint32
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	state         *bool
	role_name     *string
	role_code     *string
	description   *string
	clearedFields map[string]struct{}
	menus         map[uint32]struct{}
	removedmenus  map[uint32]struct{}
	clearedmenus  bool
	users         map[uuid.UUID]struct{}
	removedusers  map[uuid.UUID]struct{}
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*Role, error)
	predicates    []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uint32) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RoleMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RoleMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RoleMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[role.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RoleMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[role.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RoleMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, role.FieldDeletedAt)
}

// SetState sets the "state" field.
func (m *RoleMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *RoleMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *RoleMutation) ClearState() {
	m.state = nil
	m.clearedFields[role.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *RoleMutation) StateCleared() bool {
	_, ok := m.clearedFields[role.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *RoleMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, role.FieldState)
}

// SetRoleName sets the "role_name" field.
func (m *RoleMutation) SetRoleName(s string) {
	m.role_name = &s
}

// RoleName returns the value of the "role_name" field in the mutation.
func (m *RoleMutation) RoleName() (r string, exists bool) {
	v := m.role_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleName returns the old "role_name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRoleName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleName: %w", err)
	}
	return oldValue.RoleName, nil
}

// ResetRoleName resets all changes to the "role_name" field.
func (m *RoleMutation) ResetRoleName() {
	m.role_name = nil
}

// SetRoleCode sets the "role_code" field.
func (m *RoleMutation) SetRoleCode(s string) {
	m.role_code = &s
}

// RoleCode returns the value of the "role_code" field in the mutation.
func (m *RoleMutation) RoleCode() (r string, exists bool) {
	v := m.role_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleCode returns the old "role_code" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRoleCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleCode: %w", err)
	}
	return oldValue.RoleCode, nil
}

// ResetRoleCode resets all changes to the "role_code" field.
func (m *RoleMutation) ResetRoleCode() {
	m.role_code = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// AddMenuIDs adds the "menus" edge to the Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...uint32) {
	if m.menus == nil {
		m.menus = make(map[uint32]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *RoleMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *RoleMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...uint32) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Menu entity.
func (m *RoleMutation) RemovedMenusIDs() (ids []uint32) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *RoleMutation) MenusIDs() (ids []uint32) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *RoleMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.state != nil {
		fields = append(fields, role.FieldState)
	}
	if m.role_name != nil {
		fields = append(fields, role.FieldRoleName)
	}
	if m.role_code != nil {
		fields = append(fields, role.FieldRoleCode)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldDeletedAt:
		return m.DeletedAt()
	case role.FieldState:
		return m.State()
	case role.FieldRoleName:
		return m.RoleName()
	case role.FieldRoleCode:
		return m.RoleCode()
	case role.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case role.FieldState:
		return m.OldState(ctx)
	case role.FieldRoleName:
		return m.OldRoleName(ctx)
	case role.FieldRoleCode:
		return m.OldRoleCode(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case role.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case role.FieldRoleName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleName(v)
		return nil
	case role.FieldRoleCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleCode(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDeletedAt) {
		fields = append(fields, role.FieldDeletedAt)
	}
	if m.FieldCleared(role.FieldState) {
		fields = append(fields, role.FieldState)
	}
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case role.FieldState:
		m.ClearState()
		return nil
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case role.FieldState:
		m.ResetState()
		return nil
	case role.FieldRoleName:
		m.ResetRoleName()
		return nil
	case role.FieldRoleCode:
		m.ResetRoleCode()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.menus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmenus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmenus {
		edges = append(edges, role.EdgeMenus)
	}
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeMenus:
		return m.clearedmenus
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeMenus:
		m.ResetMenus()
		return nil
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op              Op
	typ             string
	id              *uint32
	created_at      *time.Time
	updated_at      *time.Time
	state           *bool
	token_value     *string
	token_type      *string
	expires_at      *time.Time
	device_info     *string
	ip_address      *string
	last_used_at    *time.Time
	user_agent      *string
	metadata        *string
	clearedFields   map[string]struct{}
	user            *uuid.UUID
	cleareduser     bool
	provider        *uint32
	clearedprovider bool
	done            bool
	oldValue        func(context.Context) (*Token, error)
	predicates      []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id uint32) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id uint32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id uint32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]uint32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetState sets the "state" field.
func (m *TokenMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *TokenMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *TokenMutation) ClearState() {
	m.state = nil
	m.clearedFields[token.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *TokenMutation) StateCleared() bool {
	_, ok := m.clearedFields[token.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *TokenMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, token.FieldState)
}

// SetTokenValue sets the "token_value" field.
func (m *TokenMutation) SetTokenValue(s string) {
	m.token_value = &s
}

// TokenValue returns the value of the "token_value" field in the mutation.
func (m *TokenMutation) TokenValue() (r string, exists bool) {
	v := m.token_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenValue returns the old "token_value" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldTokenValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenValue: %w", err)
	}
	return oldValue.TokenValue, nil
}

// ResetTokenValue resets all changes to the "token_value" field.
func (m *TokenMutation) ResetTokenValue() {
	m.token_value = nil
}

// SetTokenType sets the "token_type" field.
func (m *TokenMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *TokenMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *TokenMutation) ResetTokenType() {
	m.token_type = nil
}

// SetUserID sets the "user_id" field.
func (m *TokenMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TokenMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUserID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *TokenMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[token.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *TokenMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[token.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TokenMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, token.FieldUserID)
}

// SetExpiresAt sets the "expires_at" field.
func (m *TokenMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TokenMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TokenMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetDeviceInfo sets the "device_info" field.
func (m *TokenMutation) SetDeviceInfo(s string) {
	m.device_info = &s
}

// DeviceInfo returns the value of the "device_info" field in the mutation.
func (m *TokenMutation) DeviceInfo() (r string, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceInfo returns the old "device_info" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldDeviceInfo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceInfo: %w", err)
	}
	return oldValue.DeviceInfo, nil
}

// ClearDeviceInfo clears the value of the "device_info" field.
func (m *TokenMutation) ClearDeviceInfo() {
	m.device_info = nil
	m.clearedFields[token.FieldDeviceInfo] = struct{}{}
}

// DeviceInfoCleared returns if the "device_info" field was cleared in this mutation.
func (m *TokenMutation) DeviceInfoCleared() bool {
	_, ok := m.clearedFields[token.FieldDeviceInfo]
	return ok
}

// ResetDeviceInfo resets all changes to the "device_info" field.
func (m *TokenMutation) ResetDeviceInfo() {
	m.device_info = nil
	delete(m.clearedFields, token.FieldDeviceInfo)
}

// SetIPAddress sets the "ip_address" field.
func (m *TokenMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *TokenMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *TokenMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[token.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *TokenMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[token.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *TokenMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, token.FieldIPAddress)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *TokenMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *TokenMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *TokenMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[token.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *TokenMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *TokenMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, token.FieldLastUsedAt)
}

// SetUserAgent sets the "user_agent" field.
func (m *TokenMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *TokenMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *TokenMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[token.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *TokenMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[token.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *TokenMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, token.FieldUserAgent)
}

// SetMetadata sets the "metadata" field.
func (m *TokenMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *TokenMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldMetadata(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *TokenMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[token.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *TokenMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[token.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *TokenMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, token.FieldMetadata)
}

// SetProviderID sets the "provider_id" field.
func (m *TokenMutation) SetProviderID(u uint32) {
	m.provider = &u
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *TokenMutation) ProviderID() (r uint32, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldProviderID(ctx context.Context) (v *uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// ClearProviderID clears the value of the "provider_id" field.
func (m *TokenMutation) ClearProviderID() {
	m.provider = nil
	m.clearedFields[token.FieldProviderID] = struct{}{}
}

// ProviderIDCleared returns if the "provider_id" field was cleared in this mutation.
func (m *TokenMutation) ProviderIDCleared() bool {
	_, ok := m.clearedFields[token.FieldProviderID]
	return ok
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *TokenMutation) ResetProviderID() {
	m.provider = nil
	delete(m.clearedFields, token.FieldProviderID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *TokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[token.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TokenMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearProvider clears the "provider" edge to the OauthProvider entity.
func (m *TokenMutation) ClearProvider() {
	m.clearedprovider = true
	m.clearedFields[token.FieldProviderID] = struct{}{}
}

// ProviderCleared reports if the "provider" edge to the OauthProvider entity was cleared.
func (m *TokenMutation) ProviderCleared() bool {
	return m.ProviderIDCleared() || m.clearedprovider
}

// ProviderIDs returns the "provider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProviderID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) ProviderIDs() (ids []uint32) {
	if id := m.provider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProvider resets all changes to the "provider" edge.
func (m *TokenMutation) ResetProvider() {
	m.provider = nil
	m.clearedprovider = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, token.FieldUpdatedAt)
	}
	if m.state != nil {
		fields = append(fields, token.FieldState)
	}
	if m.token_value != nil {
		fields = append(fields, token.FieldTokenValue)
	}
	if m.token_type != nil {
		fields = append(fields, token.FieldTokenType)
	}
	if m.user != nil {
		fields = append(fields, token.FieldUserID)
	}
	if m.expires_at != nil {
		fields = append(fields, token.FieldExpiresAt)
	}
	if m.device_info != nil {
		fields = append(fields, token.FieldDeviceInfo)
	}
	if m.ip_address != nil {
		fields = append(fields, token.FieldIPAddress)
	}
	if m.last_used_at != nil {
		fields = append(fields, token.FieldLastUsedAt)
	}
	if m.user_agent != nil {
		fields = append(fields, token.FieldUserAgent)
	}
	if m.metadata != nil {
		fields = append(fields, token.FieldMetadata)
	}
	if m.provider != nil {
		fields = append(fields, token.FieldProviderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldUpdatedAt:
		return m.UpdatedAt()
	case token.FieldState:
		return m.State()
	case token.FieldTokenValue:
		return m.TokenValue()
	case token.FieldTokenType:
		return m.TokenType()
	case token.FieldUserID:
		return m.UserID()
	case token.FieldExpiresAt:
		return m.ExpiresAt()
	case token.FieldDeviceInfo:
		return m.DeviceInfo()
	case token.FieldIPAddress:
		return m.IPAddress()
	case token.FieldLastUsedAt:
		return m.LastUsedAt()
	case token.FieldUserAgent:
		return m.UserAgent()
	case token.FieldMetadata:
		return m.Metadata()
	case token.FieldProviderID:
		return m.ProviderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case token.FieldState:
		return m.OldState(ctx)
	case token.FieldTokenValue:
		return m.OldTokenValue(ctx)
	case token.FieldTokenType:
		return m.OldTokenType(ctx)
	case token.FieldUserID:
		return m.OldUserID(ctx)
	case token.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case token.FieldDeviceInfo:
		return m.OldDeviceInfo(ctx)
	case token.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case token.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case token.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case token.FieldMetadata:
		return m.OldMetadata(ctx)
	case token.FieldProviderID:
		return m.OldProviderID(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case token.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case token.FieldTokenValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenValue(v)
		return nil
	case token.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case token.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case token.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case token.FieldDeviceInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceInfo(v)
		return nil
	case token.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case token.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case token.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case token.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case token.FieldProviderID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldState) {
		fields = append(fields, token.FieldState)
	}
	if m.FieldCleared(token.FieldUserID) {
		fields = append(fields, token.FieldUserID)
	}
	if m.FieldCleared(token.FieldDeviceInfo) {
		fields = append(fields, token.FieldDeviceInfo)
	}
	if m.FieldCleared(token.FieldIPAddress) {
		fields = append(fields, token.FieldIPAddress)
	}
	if m.FieldCleared(token.FieldLastUsedAt) {
		fields = append(fields, token.FieldLastUsedAt)
	}
	if m.FieldCleared(token.FieldUserAgent) {
		fields = append(fields, token.FieldUserAgent)
	}
	if m.FieldCleared(token.FieldMetadata) {
		fields = append(fields, token.FieldMetadata)
	}
	if m.FieldCleared(token.FieldProviderID) {
		fields = append(fields, token.FieldProviderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldState:
		m.ClearState()
		return nil
	case token.FieldUserID:
		m.ClearUserID()
		return nil
	case token.FieldDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case token.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case token.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case token.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case token.FieldMetadata:
		m.ClearMetadata()
		return nil
	case token.FieldProviderID:
		m.ClearProviderID()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case token.FieldState:
		m.ResetState()
		return nil
	case token.FieldTokenValue:
		m.ResetTokenValue()
		return nil
	case token.FieldTokenType:
		m.ResetTokenType()
		return nil
	case token.FieldUserID:
		m.ResetUserID()
		return nil
	case token.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case token.FieldDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case token.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case token.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case token.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case token.FieldMetadata:
		m.ResetMetadata()
		return nil
	case token.FieldProviderID:
		m.ResetProviderID()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, token.EdgeUser)
	}
	if m.provider != nil {
		edges = append(edges, token.EdgeProvider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case token.EdgeProvider:
		if id := m.provider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, token.EdgeUser)
	}
	if m.clearedprovider {
		edges = append(edges, token.EdgeProvider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeUser:
		return m.cleareduser
	case token.EdgeProvider:
		return m.clearedprovider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeUser:
		m.ClearUser()
		return nil
	case token.EdgeProvider:
		m.ClearProvider()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeUser:
		m.ResetUser()
		return nil
	case token.EdgeProvider:
		m.ResetProvider()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	state                    *bool
	username                 *string
	password_hash            *string
	email                    *string
	full_name                *string
	mobile                   *string
	avatar                   *string
	user_description         *string
	last_login_at            *time.Time
	last_login_ip            *string
	home_path                *string
	clearedFields            map[string]struct{}
	roles                    map[uint32]struct{}
	removedroles             map[uint32]struct{}
	clearedroles             bool
	positions                map[uint32]struct{}
	removedpositions         map[uint32]struct{}
	clearedpositions         bool
	department               *uint32
	cleareddepartment        bool
	leader_department        map[uint32]struct{}
	removedleader_department map[uint32]struct{}
	clearedleader_department bool
	totp                     *uuid.UUID
	clearedtotp              bool
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetState sets the "state" field.
func (m *UserMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *UserMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *UserMutation) ClearState() {
	m.state = nil
	m.clearedFields[user.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *UserMutation) StateCleared() bool {
	_, ok := m.clearedFields[user.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *UserMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, user.FieldState)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetFullName sets the "full_name" field.
func (m *UserMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *UserMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ClearFullName clears the value of the "full_name" field.
func (m *UserMutation) ClearFullName() {
	m.full_name = nil
	m.clearedFields[user.FieldFullName] = struct{}{}
}

// FullNameCleared returns if the "full_name" field was cleared in this mutation.
func (m *UserMutation) FullNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFullName]
	return ok
}

// ResetFullName resets all changes to the "full_name" field.
func (m *UserMutation) ResetFullName() {
	m.full_name = nil
	delete(m.clearedFields, user.FieldFullName)
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "mobile" field.
func (m *UserMutation) ClearMobile() {
	m.mobile = nil
	m.clearedFields[user.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "mobile" field was cleared in this mutation.
func (m *UserMutation) MobileCleared() bool {
	_, ok := m.clearedFields[user.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
	delete(m.clearedFields, user.FieldMobile)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetUserDescription sets the "user_description" field.
func (m *UserMutation) SetUserDescription(s string) {
	m.user_description = &s
}

// UserDescription returns the value of the "user_description" field in the mutation.
func (m *UserMutation) UserDescription() (r string, exists bool) {
	v := m.user_description
	if v == nil {
		return
	}
	return *v, true
}

// OldUserDescription returns the old "user_description" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserDescription: %w", err)
	}
	return oldValue.UserDescription, nil
}

// ClearUserDescription clears the value of the "user_description" field.
func (m *UserMutation) ClearUserDescription() {
	m.user_description = nil
	m.clearedFields[user.FieldUserDescription] = struct{}{}
}

// UserDescriptionCleared returns if the "user_description" field was cleared in this mutation.
func (m *UserMutation) UserDescriptionCleared() bool {
	_, ok := m.clearedFields[user.FieldUserDescription]
	return ok
}

// ResetUserDescription resets all changes to the "user_description" field.
func (m *UserMutation) ResetUserDescription() {
	m.user_description = nil
	delete(m.clearedFields, user.FieldUserDescription)
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *UserMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *UserMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *UserMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[user.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *UserMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *UserMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, user.FieldLastLoginAt)
}

// SetLastLoginIP sets the "last_login_ip" field.
func (m *UserMutation) SetLastLoginIP(s string) {
	m.last_login_ip = &s
}

// LastLoginIP returns the value of the "last_login_ip" field in the mutation.
func (m *UserMutation) LastLoginIP() (r string, exists bool) {
	v := m.last_login_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginIP returns the old "last_login_ip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLoginIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginIP: %w", err)
	}
	return oldValue.LastLoginIP, nil
}

// ClearLastLoginIP clears the value of the "last_login_ip" field.
func (m *UserMutation) ClearLastLoginIP() {
	m.last_login_ip = nil
	m.clearedFields[user.FieldLastLoginIP] = struct{}{}
}

// LastLoginIPCleared returns if the "last_login_ip" field was cleared in this mutation.
func (m *UserMutation) LastLoginIPCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLoginIP]
	return ok
}

// ResetLastLoginIP resets all changes to the "last_login_ip" field.
func (m *UserMutation) ResetLastLoginIP() {
	m.last_login_ip = nil
	delete(m.clearedFields, user.FieldLastLoginIP)
}

// SetDepartmentID sets the "department_id" field.
func (m *UserMutation) SetDepartmentID(u uint32) {
	m.department = &u
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *UserMutation) DepartmentID() (r uint32, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDepartmentID(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *UserMutation) ClearDepartmentID() {
	m.department = nil
	m.clearedFields[user.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *UserMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[user.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *UserMutation) ResetDepartmentID() {
	m.department = nil
	delete(m.clearedFields, user.FieldDepartmentID)
}

// SetHomePath sets the "home_path" field.
func (m *UserMutation) SetHomePath(s string) {
	m.home_path = &s
}

// HomePath returns the value of the "home_path" field in the mutation.
func (m *UserMutation) HomePath() (r string, exists bool) {
	v := m.home_path
	if v == nil {
		return
	}
	return *v, true
}

// OldHomePath returns the old "home_path" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHomePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomePath: %w", err)
	}
	return oldValue.HomePath, nil
}

// ClearHomePath clears the value of the "home_path" field.
func (m *UserMutation) ClearHomePath() {
	m.home_path = nil
	m.clearedFields[user.FieldHomePath] = struct{}{}
}

// HomePathCleared returns if the "home_path" field was cleared in this mutation.
func (m *UserMutation) HomePathCleared() bool {
	_, ok := m.clearedFields[user.FieldHomePath]
	return ok
}

// ResetHomePath resets all changes to the "home_path" field.
func (m *UserMutation) ResetHomePath() {
	m.home_path = nil
	delete(m.clearedFields, user.FieldHomePath)
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...uint32) {
	if m.roles == nil {
		m.roles = make(map[uint32]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...uint32) {
	if m.removedroles == nil {
		m.removedroles = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []uint32) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []uint32) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddPositionIDs adds the "positions" edge to the Position entity by ids.
func (m *UserMutation) AddPositionIDs(ids ...uint32) {
	if m.positions == nil {
		m.positions = make(map[uint32]struct{})
	}
	for i := range ids {
		m.positions[ids[i]] = struct{}{}
	}
}

// ClearPositions clears the "positions" edge to the Position entity.
func (m *UserMutation) ClearPositions() {
	m.clearedpositions = true
}

// PositionsCleared reports if the "positions" edge to the Position entity was cleared.
func (m *UserMutation) PositionsCleared() bool {
	return m.clearedpositions
}

// RemovePositionIDs removes the "positions" edge to the Position entity by IDs.
func (m *UserMutation) RemovePositionIDs(ids ...uint32) {
	if m.removedpositions == nil {
		m.removedpositions = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.positions, ids[i])
		m.removedpositions[ids[i]] = struct{}{}
	}
}

// RemovedPositions returns the removed IDs of the "positions" edge to the Position entity.
func (m *UserMutation) RemovedPositionsIDs() (ids []uint32) {
	for id := range m.removedpositions {
		ids = append(ids, id)
	}
	return
}

// PositionsIDs returns the "positions" edge IDs in the mutation.
func (m *UserMutation) PositionsIDs() (ids []uint32) {
	for id := range m.positions {
		ids = append(ids, id)
	}
	return
}

// ResetPositions resets all changes to the "positions" edge.
func (m *UserMutation) ResetPositions() {
	m.positions = nil
	m.clearedpositions = false
	m.removedpositions = nil
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *UserMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[user.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *UserMutation) DepartmentCleared() bool {
	return m.DepartmentIDCleared() || m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) DepartmentIDs() (ids []uint32) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *UserMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// AddLeaderDepartmentIDs adds the "leader_department" edge to the Department entity by ids.
func (m *UserMutation) AddLeaderDepartmentIDs(ids ...uint32) {
	if m.leader_department == nil {
		m.leader_department = make(map[uint32]struct{})
	}
	for i := range ids {
		m.leader_department[ids[i]] = struct{}{}
	}
}

// ClearLeaderDepartment clears the "leader_department" edge to the Department entity.
func (m *UserMutation) ClearLeaderDepartment() {
	m.clearedleader_department = true
}

// LeaderDepartmentCleared reports if the "leader_department" edge to the Department entity was cleared.
func (m *UserMutation) LeaderDepartmentCleared() bool {
	return m.clearedleader_department
}

// RemoveLeaderDepartmentIDs removes the "leader_department" edge to the Department entity by IDs.
func (m *UserMutation) RemoveLeaderDepartmentIDs(ids ...uint32) {
	if m.removedleader_department == nil {
		m.removedleader_department = make(map[uint32]struct{})
	}
	for i := range ids {
		delete(m.leader_department, ids[i])
		m.removedleader_department[ids[i]] = struct{}{}
	}
}

// RemovedLeaderDepartment returns the removed IDs of the "leader_department" edge to the Department entity.
func (m *UserMutation) RemovedLeaderDepartmentIDs() (ids []uint32) {
	for id := range m.removedleader_department {
		ids = append(ids, id)
	}
	return
}

// LeaderDepartmentIDs returns the "leader_department" edge IDs in the mutation.
func (m *UserMutation) LeaderDepartmentIDs() (ids []uint32) {
	for id := range m.leader_department {
		ids = append(ids, id)
	}
	return
}

// ResetLeaderDepartment resets all changes to the "leader_department" edge.
func (m *UserMutation) ResetLeaderDepartment() {
	m.leader_department = nil
	m.clearedleader_department = false
	m.removedleader_department = nil
}

// SetTotpID sets the "totp" edge to the UserTotp entity by id.
func (m *UserMutation) SetTotpID(id uuid.UUID) {
	m.totp = &id
}

// ClearTotp clears the "totp" edge to the UserTotp entity.
func (m *UserMutation) ClearTotp() {
	m.clearedtotp = true
}

// TotpCleared reports if the "totp" edge to the UserTotp entity was cleared.
func (m *UserMutation) TotpCleared() bool {
	return m.clearedtotp
}

// TotpID returns the "totp" edge ID in the mutation.
func (m *UserMutation) TotpID() (id uuid.UUID, exists bool) {
	if m.totp != nil {
		return *m.totp, true
	}
	return
}

// TotpIDs returns the "totp" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TotpID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TotpIDs() (ids []uuid.UUID) {
	if id := m.totp; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTotp resets all changes to the "totp" edge.
func (m *UserMutation) ResetTotp() {
	m.totp = nil
	m.clearedtotp = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.state != nil {
		fields = append(fields, user.FieldState)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.full_name != nil {
		fields = append(fields, user.FieldFullName)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.user_description != nil {
		fields = append(fields, user.FieldUserDescription)
	}
	if m.last_login_at != nil {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.last_login_ip != nil {
		fields = append(fields, user.FieldLastLoginIP)
	}
	if m.department != nil {
		fields = append(fields, user.FieldDepartmentID)
	}
	if m.home_path != nil {
		fields = append(fields, user.FieldHomePath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldState:
		return m.State()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFullName:
		return m.FullName()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldUserDescription:
		return m.UserDescription()
	case user.FieldLastLoginAt:
		return m.LastLoginAt()
	case user.FieldLastLoginIP:
		return m.LastLoginIP()
	case user.FieldDepartmentID:
		return m.DepartmentID()
	case user.FieldHomePath:
		return m.HomePath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldState:
		return m.OldState(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFullName:
		return m.OldFullName(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldUserDescription:
		return m.OldUserDescription(ctx)
	case user.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case user.FieldLastLoginIP:
		return m.OldLastLoginIP(ctx)
	case user.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case user.FieldHomePath:
		return m.OldHomePath(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldUserDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserDescription(v)
		return nil
	case user.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case user.FieldLastLoginIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginIP(v)
		return nil
	case user.FieldDepartmentID:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case user.FieldHomePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomePath(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldState) {
		fields = append(fields, user.FieldState)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldFullName) {
		fields = append(fields, user.FieldFullName)
	}
	if m.FieldCleared(user.FieldMobile) {
		fields = append(fields, user.FieldMobile)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldUserDescription) {
		fields = append(fields, user.FieldUserDescription)
	}
	if m.FieldCleared(user.FieldLastLoginAt) {
		fields = append(fields, user.FieldLastLoginAt)
	}
	if m.FieldCleared(user.FieldLastLoginIP) {
		fields = append(fields, user.FieldLastLoginIP)
	}
	if m.FieldCleared(user.FieldDepartmentID) {
		fields = append(fields, user.FieldDepartmentID)
	}
	if m.FieldCleared(user.FieldHomePath) {
		fields = append(fields, user.FieldHomePath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldState:
		m.ClearState()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldFullName:
		m.ClearFullName()
		return nil
	case user.FieldMobile:
		m.ClearMobile()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldUserDescription:
		m.ClearUserDescription()
		return nil
	case user.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	case user.FieldLastLoginIP:
		m.ClearLastLoginIP()
		return nil
	case user.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	case user.FieldHomePath:
		m.ClearHomePath()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldState:
		m.ResetState()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFullName:
		m.ResetFullName()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldUserDescription:
		m.ResetUserDescription()
		return nil
	case user.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case user.FieldLastLoginIP:
		m.ResetLastLoginIP()
		return nil
	case user.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case user.FieldHomePath:
		m.ResetHomePath()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.positions != nil {
		edges = append(edges, user.EdgePositions)
	}
	if m.department != nil {
		edges = append(edges, user.EdgeDepartment)
	}
	if m.leader_department != nil {
		edges = append(edges, user.EdgeLeaderDepartment)
	}
	if m.totp != nil {
		edges = append(edges, user.EdgeTotp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePositions:
		ids := make([]ent.Value, 0, len(m.positions))
		for id := range m.positions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeLeaderDepartment:
		ids := make([]ent.Value, 0, len(m.leader_department))
		for id := range m.leader_department {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTotp:
		if id := m.totp; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	if m.removedpositions != nil {
		edges = append(edges, user.EdgePositions)
	}
	if m.removedleader_department != nil {
		edges = append(edges, user.EdgeLeaderDepartment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePositions:
		ids := make([]ent.Value, 0, len(m.removedpositions))
		for id := range m.removedpositions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLeaderDepartment:
		ids := make([]ent.Value, 0, len(m.removedleader_department))
		for id := range m.removedleader_department {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	if m.clearedpositions {
		edges = append(edges, user.EdgePositions)
	}
	if m.cleareddepartment {
		edges = append(edges, user.EdgeDepartment)
	}
	if m.clearedleader_department {
		edges = append(edges, user.EdgeLeaderDepartment)
	}
	if m.clearedtotp {
		edges = append(edges, user.EdgeTotp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeRoles:
		return m.clearedroles
	case user.EdgePositions:
		return m.clearedpositions
	case user.EdgeDepartment:
		return m.cleareddepartment
	case user.EdgeLeaderDepartment:
		return m.clearedleader_department
	case user.EdgeTotp:
		return m.clearedtotp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case user.EdgeTotp:
		m.ClearTotp()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	case user.EdgePositions:
		m.ResetPositions()
		return nil
	case user.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case user.EdgeLeaderDepartment:
		m.ResetLeaderDepartment()
		return nil
	case user.EdgeTotp:
		m.ResetTotp()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserTotpMutation represents an operation that mutates the UserTotp nodes in the graph.
type UserTotpMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	state          *bool
	secret_key     *string
	backup_codes   *string
	is_verified    *bool
	last_used_at   *time.Time
	last_used_code *string
	device_name    *string
	issuer         *string
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserTotp, error)
	predicates     []predicate.UserTotp
}

var _ ent.Mutation = (*UserTotpMutation)(nil)

// usertotpOption allows management of the mutation configuration using functional options.
type usertotpOption func(*UserTotpMutation)

// newUserTotpMutation creates new mutation for the UserTotp entity.
func newUserTotpMutation(c config, op Op, opts ...usertotpOption) *UserTotpMutation {
	m := &UserTotpMutation{
		config:        c,
		op:            op,
		typ:           TypeUserTotp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserTotpID sets the ID field of the mutation.
func withUserTotpID(id uuid.UUID) usertotpOption {
	return func(m *UserTotpMutation) {
		var (
			err   error
			once  sync.Once
			value *UserTotp
		)
		m.oldValue = func(ctx context.Context) (*UserTotp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserTotp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserTotp sets the old UserTotp of the mutation.
func withUserTotp(node *UserTotp) usertotpOption {
	return func(m *UserTotpMutation) {
		m.oldValue = func(context.Context) (*UserTotp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserTotpMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserTotpMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserTotp entities.
func (m *UserTotpMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserTotpMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserTotpMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserTotp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserTotpMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserTotpMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserTotp entity.
// If the UserTotp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTotpMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserTotpMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserTotpMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserTotpMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserTotp entity.
// If the UserTotp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTotpMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserTotpMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetState sets the "state" field.
func (m *UserTotpMutation) SetState(b bool) {
	m.state = &b
}

// State returns the value of the "state" field in the mutation.
func (m *UserTotpMutation) State() (r bool, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the UserTotp entity.
// If the UserTotp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTotpMutation) OldState(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *UserTotpMutation) ClearState() {
	m.state = nil
	m.clearedFields[usertotp.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *UserTotpMutation) StateCleared() bool {
	_, ok := m.clearedFields[usertotp.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *UserTotpMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, usertotp.FieldState)
}

// SetSecretKey sets the "secret_key" field.
func (m *UserTotpMutation) SetSecretKey(s string) {
	m.secret_key = &s
}

// SecretKey returns the value of the "secret_key" field in the mutation.
func (m *UserTotpMutation) SecretKey() (r string, exists bool) {
	v := m.secret_key
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "secret_key" field's value of the UserTotp entity.
// If the UserTotp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTotpMutation) OldSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ResetSecretKey resets all changes to the "secret_key" field.
func (m *UserTotpMutation) ResetSecretKey() {
	m.secret_key = nil
}

// SetBackupCodes sets the "backup_codes" field.
func (m *UserTotpMutation) SetBackupCodes(s string) {
	m.backup_codes = &s
}

// BackupCodes returns the value of the "backup_codes" field in the mutation.
func (m *UserTotpMutation) BackupCodes() (r string, exists bool) {
	v := m.backup_codes
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupCodes returns the old "backup_codes" field's value of the UserTotp entity.
// If the UserTotp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTotpMutation) OldBackupCodes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupCodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupCodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupCodes: %w", err)
	}
	return oldValue.BackupCodes, nil
}

// ClearBackupCodes clears the value of the "backup_codes" field.
func (m *UserTotpMutation) ClearBackupCodes() {
	m.backup_codes = nil
	m.clearedFields[usertotp.FieldBackupCodes] = struct{}{}
}

// BackupCodesCleared returns if the "backup_codes" field was cleared in this mutation.
func (m *UserTotpMutation) BackupCodesCleared() bool {
	_, ok := m.clearedFields[usertotp.FieldBackupCodes]
	return ok
}

// ResetBackupCodes resets all changes to the "backup_codes" field.
func (m *UserTotpMutation) ResetBackupCodes() {
	m.backup_codes = nil
	delete(m.clearedFields, usertotp.FieldBackupCodes)
}

// SetIsVerified sets the "is_verified" field.
func (m *UserTotpMutation) SetIsVerified(b bool) {
	m.is_verified = &b
}

// IsVerified returns the value of the "is_verified" field in the mutation.
func (m *UserTotpMutation) IsVerified() (r bool, exists bool) {
	v := m.is_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVerified returns the old "is_verified" field's value of the UserTotp entity.
// If the UserTotp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTotpMutation) OldIsVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVerified: %w", err)
	}
	return oldValue.IsVerified, nil
}

// ResetIsVerified resets all changes to the "is_verified" field.
func (m *UserTotpMutation) ResetIsVerified() {
	m.is_verified = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *UserTotpMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *UserTotpMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the UserTotp entity.
// If the UserTotp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTotpMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *UserTotpMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[usertotp.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *UserTotpMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[usertotp.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *UserTotpMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, usertotp.FieldLastUsedAt)
}

// SetLastUsedCode sets the "last_used_code" field.
func (m *UserTotpMutation) SetLastUsedCode(s string) {
	m.last_used_code = &s
}

// LastUsedCode returns the value of the "last_used_code" field in the mutation.
func (m *UserTotpMutation) LastUsedCode() (r string, exists bool) {
	v := m.last_used_code
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedCode returns the old "last_used_code" field's value of the UserTotp entity.
// If the UserTotp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTotpMutation) OldLastUsedCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedCode: %w", err)
	}
	return oldValue.LastUsedCode, nil
}

// ClearLastUsedCode clears the value of the "last_used_code" field.
func (m *UserTotpMutation) ClearLastUsedCode() {
	m.last_used_code = nil
	m.clearedFields[usertotp.FieldLastUsedCode] = struct{}{}
}

// LastUsedCodeCleared returns if the "last_used_code" field was cleared in this mutation.
func (m *UserTotpMutation) LastUsedCodeCleared() bool {
	_, ok := m.clearedFields[usertotp.FieldLastUsedCode]
	return ok
}

// ResetLastUsedCode resets all changes to the "last_used_code" field.
func (m *UserTotpMutation) ResetLastUsedCode() {
	m.last_used_code = nil
	delete(m.clearedFields, usertotp.FieldLastUsedCode)
}

// SetDeviceName sets the "device_name" field.
func (m *UserTotpMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *UserTotpMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the UserTotp entity.
// If the UserTotp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTotpMutation) OldDeviceName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ClearDeviceName clears the value of the "device_name" field.
func (m *UserTotpMutation) ClearDeviceName() {
	m.device_name = nil
	m.clearedFields[usertotp.FieldDeviceName] = struct{}{}
}

// DeviceNameCleared returns if the "device_name" field was cleared in this mutation.
func (m *UserTotpMutation) DeviceNameCleared() bool {
	_, ok := m.clearedFields[usertotp.FieldDeviceName]
	return ok
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *UserTotpMutation) ResetDeviceName() {
	m.device_name = nil
	delete(m.clearedFields, usertotp.FieldDeviceName)
}

// SetIssuer sets the "issuer" field.
func (m *UserTotpMutation) SetIssuer(s string) {
	m.issuer = &s
}

// Issuer returns the value of the "issuer" field in the mutation.
func (m *UserTotpMutation) Issuer() (r string, exists bool) {
	v := m.issuer
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuer returns the old "issuer" field's value of the UserTotp entity.
// If the UserTotp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTotpMutation) OldIssuer(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuer: %w", err)
	}
	return oldValue.Issuer, nil
}

// ClearIssuer clears the value of the "issuer" field.
func (m *UserTotpMutation) ClearIssuer() {
	m.issuer = nil
	m.clearedFields[usertotp.FieldIssuer] = struct{}{}
}

// IssuerCleared returns if the "issuer" field was cleared in this mutation.
func (m *UserTotpMutation) IssuerCleared() bool {
	_, ok := m.clearedFields[usertotp.FieldIssuer]
	return ok
}

// ResetIssuer resets all changes to the "issuer" field.
func (m *UserTotpMutation) ResetIssuer() {
	m.issuer = nil
	delete(m.clearedFields, usertotp.FieldIssuer)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserTotpMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserTotpMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserTotpMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserTotpMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserTotpMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserTotpMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserTotpMutation builder.
func (m *UserTotpMutation) Where(ps ...predicate.UserTotp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserTotpMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserTotpMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserTotp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserTotpMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserTotpMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserTotp).
func (m *UserTotpMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserTotpMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, usertotp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usertotp.FieldUpdatedAt)
	}
	if m.state != nil {
		fields = append(fields, usertotp.FieldState)
	}
	if m.secret_key != nil {
		fields = append(fields, usertotp.FieldSecretKey)
	}
	if m.backup_codes != nil {
		fields = append(fields, usertotp.FieldBackupCodes)
	}
	if m.is_verified != nil {
		fields = append(fields, usertotp.FieldIsVerified)
	}
	if m.last_used_at != nil {
		fields = append(fields, usertotp.FieldLastUsedAt)
	}
	if m.last_used_code != nil {
		fields = append(fields, usertotp.FieldLastUsedCode)
	}
	if m.device_name != nil {
		fields = append(fields, usertotp.FieldDeviceName)
	}
	if m.issuer != nil {
		fields = append(fields, usertotp.FieldIssuer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserTotpMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usertotp.FieldCreatedAt:
		return m.CreatedAt()
	case usertotp.FieldUpdatedAt:
		return m.UpdatedAt()
	case usertotp.FieldState:
		return m.State()
	case usertotp.FieldSecretKey:
		return m.SecretKey()
	case usertotp.FieldBackupCodes:
		return m.BackupCodes()
	case usertotp.FieldIsVerified:
		return m.IsVerified()
	case usertotp.FieldLastUsedAt:
		return m.LastUsedAt()
	case usertotp.FieldLastUsedCode:
		return m.LastUsedCode()
	case usertotp.FieldDeviceName:
		return m.DeviceName()
	case usertotp.FieldIssuer:
		return m.Issuer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserTotpMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usertotp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usertotp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usertotp.FieldState:
		return m.OldState(ctx)
	case usertotp.FieldSecretKey:
		return m.OldSecretKey(ctx)
	case usertotp.FieldBackupCodes:
		return m.OldBackupCodes(ctx)
	case usertotp.FieldIsVerified:
		return m.OldIsVerified(ctx)
	case usertotp.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case usertotp.FieldLastUsedCode:
		return m.OldLastUsedCode(ctx)
	case usertotp.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case usertotp.FieldIssuer:
		return m.OldIssuer(ctx)
	}
	return nil, fmt.Errorf("unknown UserTotp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTotpMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usertotp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usertotp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usertotp.FieldState:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case usertotp.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	case usertotp.FieldBackupCodes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupCodes(v)
		return nil
	case usertotp.FieldIsVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVerified(v)
		return nil
	case usertotp.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case usertotp.FieldLastUsedCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedCode(v)
		return nil
	case usertotp.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case usertotp.FieldIssuer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuer(v)
		return nil
	}
	return fmt.Errorf("unknown UserTotp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserTotpMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserTotpMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTotpMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserTotp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserTotpMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usertotp.FieldState) {
		fields = append(fields, usertotp.FieldState)
	}
	if m.FieldCleared(usertotp.FieldBackupCodes) {
		fields = append(fields, usertotp.FieldBackupCodes)
	}
	if m.FieldCleared(usertotp.FieldLastUsedAt) {
		fields = append(fields, usertotp.FieldLastUsedAt)
	}
	if m.FieldCleared(usertotp.FieldLastUsedCode) {
		fields = append(fields, usertotp.FieldLastUsedCode)
	}
	if m.FieldCleared(usertotp.FieldDeviceName) {
		fields = append(fields, usertotp.FieldDeviceName)
	}
	if m.FieldCleared(usertotp.FieldIssuer) {
		fields = append(fields, usertotp.FieldIssuer)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserTotpMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserTotpMutation) ClearField(name string) error {
	switch name {
	case usertotp.FieldState:
		m.ClearState()
		return nil
	case usertotp.FieldBackupCodes:
		m.ClearBackupCodes()
		return nil
	case usertotp.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case usertotp.FieldLastUsedCode:
		m.ClearLastUsedCode()
		return nil
	case usertotp.FieldDeviceName:
		m.ClearDeviceName()
		return nil
	case usertotp.FieldIssuer:
		m.ClearIssuer()
		return nil
	}
	return fmt.Errorf("unknown UserTotp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserTotpMutation) ResetField(name string) error {
	switch name {
	case usertotp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usertotp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usertotp.FieldState:
		m.ResetState()
		return nil
	case usertotp.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	case usertotp.FieldBackupCodes:
		m.ResetBackupCodes()
		return nil
	case usertotp.FieldIsVerified:
		m.ResetIsVerified()
		return nil
	case usertotp.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case usertotp.FieldLastUsedCode:
		m.ResetLastUsedCode()
		return nil
	case usertotp.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case usertotp.FieldIssuer:
		m.ResetIssuer()
		return nil
	}
	return fmt.Errorf("unknown UserTotp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserTotpMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usertotp.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserTotpMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usertotp.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserTotpMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserTotpMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserTotpMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usertotp.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserTotpMutation) EdgeCleared(name string) bool {
	switch name {
	case usertotp.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserTotpMutation) ClearEdge(name string) error {
	switch name {
	case usertotp.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserTotp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserTotpMutation) ResetEdge(name string) error {
	switch name {
	case usertotp.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserTotp edge %s", name)
}
