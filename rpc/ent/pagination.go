// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"

	"github.com/wenpiner/last-admin-core/rpc/ent/api"
	"github.com/wenpiner/last-admin-core/rpc/ent/configuration"
	"github.com/wenpiner/last-admin-core/rpc/ent/department"
	"github.com/wenpiner/last-admin-core/rpc/ent/dictitem"
	"github.com/wenpiner/last-admin-core/rpc/ent/dicttype"
	"github.com/wenpiner/last-admin-core/rpc/ent/menu"
	"github.com/wenpiner/last-admin-core/rpc/ent/oauthprovider"
	"github.com/wenpiner/last-admin-core/rpc/ent/operationlog"
	"github.com/wenpiner/last-admin-core/rpc/ent/position"
	"github.com/wenpiner/last-admin-core/rpc/ent/role"
	"github.com/wenpiner/last-admin-core/rpc/ent/token"
	"github.com/wenpiner/last-admin-core/rpc/ent/user"
	"github.com/wenpiner/last-admin-core/rpc/ent/useroauth"
	"github.com/wenpiner/last-admin-core/rpc/ent/usertotp"
)

// Pagination constants
const (
	errInvalidPage       = "INVALID_PAGE"
	errInvalidPagination = "INVALID_PAGINATION"
	listField            = "list"
	pageNumField         = "pageNum"
	pageSizeField        = "pageSize"
	defaultPageSize      = 10
	maxPageSize          = 1000
)

// PageDetails contains pagination metadata
type PageDetails struct {
	Page  uint32 `json:"page"`
	Size  uint32 `json:"size"`
	Total uint64 `json:"total"`
	Pages uint32 `json:"pages"`
}

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// Reverse returns the opposite direction.
func (o OrderDirection) Reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

// ValidatePageParams validates pagination parameters
func ValidatePageParams(pageNum, pageSize uint32) error {
	if pageNum < 1 {
		return fmt.Errorf("%s: page number must be greater than 0", errInvalidPage)
	}
	if pageSize < 1 {
		return fmt.Errorf("%s: page size must be greater than 0", errInvalidPagination)
	}
	if pageSize > maxPageSize {
		return fmt.Errorf("%s: page size cannot exceed %d", errInvalidPagination, maxPageSize)
	}
	return nil
}

// CalculateOffset calculates the offset for pagination
func CalculateOffset(pageNum, pageSize uint32) int {
	return int((pageNum - 1) * pageSize)
}

// CalculatePages calculates total pages from total count and page size
func CalculatePages(total uint64, pageSize uint32) uint32 {
	if total == 0 || pageSize == 0 {
		return 0
	}
	return uint32((total + uint64(pageSize) - 1) / uint64(pageSize))
}

// APIPager provides pagination functionality for API
type APIPager struct {
	Order  api.OrderOption
	Filter func(*APIQuery) (*APIQuery, error)
}

// APIPaginateOption enables pagination customization.
type APIPaginateOption func(*APIPager)

// DefaultAPIOrder is the default ordering of API.
var DefaultAPIOrder = Desc(api.FieldID)

// NewAPIPager creates a new pager with the given options
func NewAPIPager(opts ...APIPaginateOption) (*APIPager, error) {
	pager := &APIPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultAPIOrder
	}
	return pager, nil
}

// WithOrder sets the order option for API pagination
func WithAPIOrder(order api.OrderOption) APIPaginateOption {
	return func(p *APIPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for API pagination
func WithAPIFilter(filter func(*APIQuery) (*APIQuery, error)) APIPaginateOption {
	return func(p *APIPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *APIPager) ApplyFilter(query *APIQuery) (*APIQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// APIPageList is API PageList result.
type APIPageList struct {
	List        []*API       `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

// Page performs paginated query for API
func (_m *APIQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...APIPaginateOption,
) (*APIPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewAPIPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &APIPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count api: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*API{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultAPIOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query api: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for API
func (_m *APIQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...APIPaginateOption,
) (*APIPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewAPIPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &APIPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*API{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultAPIOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query api: %w", err)
	}

	ret.List = list
	return ret, nil
}

// ConfigurationPager provides pagination functionality for Configuration
type ConfigurationPager struct {
	Order  configuration.OrderOption
	Filter func(*ConfigurationQuery) (*ConfigurationQuery, error)
}

// ConfigurationPaginateOption enables pagination customization.
type ConfigurationPaginateOption func(*ConfigurationPager)

// DefaultConfigurationOrder is the default ordering of Configuration.
var DefaultConfigurationOrder = Desc(configuration.FieldID)

// NewConfigurationPager creates a new pager with the given options
func NewConfigurationPager(opts ...ConfigurationPaginateOption) (*ConfigurationPager, error) {
	pager := &ConfigurationPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultConfigurationOrder
	}
	return pager, nil
}

// WithOrder sets the order option for Configuration pagination
func WithConfigurationOrder(order configuration.OrderOption) ConfigurationPaginateOption {
	return func(p *ConfigurationPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for Configuration pagination
func WithConfigurationFilter(filter func(*ConfigurationQuery) (*ConfigurationQuery, error)) ConfigurationPaginateOption {
	return func(p *ConfigurationPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *ConfigurationPager) ApplyFilter(query *ConfigurationQuery) (*ConfigurationQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// ConfigurationPageList is Configuration PageList result.
type ConfigurationPageList struct {
	List        []*Configuration `json:"list"`
	PageDetails *PageDetails     `json:"pageDetails"`
}

// Page performs paginated query for Configuration
func (_m *ConfigurationQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...ConfigurationPaginateOption,
) (*ConfigurationPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewConfigurationPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &ConfigurationPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count configuration: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*Configuration{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultConfigurationOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query configuration: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for Configuration
func (_m *ConfigurationQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...ConfigurationPaginateOption,
) (*ConfigurationPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewConfigurationPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &ConfigurationPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*Configuration{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultConfigurationOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query configuration: %w", err)
	}

	ret.List = list
	return ret, nil
}

// DepartmentPager provides pagination functionality for Department
type DepartmentPager struct {
	Order  department.OrderOption
	Filter func(*DepartmentQuery) (*DepartmentQuery, error)
}

// DepartmentPaginateOption enables pagination customization.
type DepartmentPaginateOption func(*DepartmentPager)

// DefaultDepartmentOrder is the default ordering of Department.
var DefaultDepartmentOrder = Desc(department.FieldID)

// NewDepartmentPager creates a new pager with the given options
func NewDepartmentPager(opts ...DepartmentPaginateOption) (*DepartmentPager, error) {
	pager := &DepartmentPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultDepartmentOrder
	}
	return pager, nil
}

// WithOrder sets the order option for Department pagination
func WithDepartmentOrder(order department.OrderOption) DepartmentPaginateOption {
	return func(p *DepartmentPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for Department pagination
func WithDepartmentFilter(filter func(*DepartmentQuery) (*DepartmentQuery, error)) DepartmentPaginateOption {
	return func(p *DepartmentPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *DepartmentPager) ApplyFilter(query *DepartmentQuery) (*DepartmentQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// DepartmentPageList is Department PageList result.
type DepartmentPageList struct {
	List        []*Department `json:"list"`
	PageDetails *PageDetails  `json:"pageDetails"`
}

// Page performs paginated query for Department
func (_m *DepartmentQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...DepartmentPaginateOption,
) (*DepartmentPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewDepartmentPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &DepartmentPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count department: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*Department{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultDepartmentOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query department: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for Department
func (_m *DepartmentQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...DepartmentPaginateOption,
) (*DepartmentPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewDepartmentPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &DepartmentPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*Department{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultDepartmentOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query department: %w", err)
	}

	ret.List = list
	return ret, nil
}

// DictItemPager provides pagination functionality for DictItem
type DictItemPager struct {
	Order  dictitem.OrderOption
	Filter func(*DictItemQuery) (*DictItemQuery, error)
}

// DictItemPaginateOption enables pagination customization.
type DictItemPaginateOption func(*DictItemPager)

// DefaultDictItemOrder is the default ordering of DictItem.
var DefaultDictItemOrder = Desc(dictitem.FieldID)

// NewDictItemPager creates a new pager with the given options
func NewDictItemPager(opts ...DictItemPaginateOption) (*DictItemPager, error) {
	pager := &DictItemPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultDictItemOrder
	}
	return pager, nil
}

// WithOrder sets the order option for DictItem pagination
func WithDictItemOrder(order dictitem.OrderOption) DictItemPaginateOption {
	return func(p *DictItemPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for DictItem pagination
func WithDictItemFilter(filter func(*DictItemQuery) (*DictItemQuery, error)) DictItemPaginateOption {
	return func(p *DictItemPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *DictItemPager) ApplyFilter(query *DictItemQuery) (*DictItemQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// DictItemPageList is DictItem PageList result.
type DictItemPageList struct {
	List        []*DictItem  `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

// Page performs paginated query for DictItem
func (_m *DictItemQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...DictItemPaginateOption,
) (*DictItemPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewDictItemPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &DictItemPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count dictitem: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*DictItem{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultDictItemOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query dictitem: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for DictItem
func (_m *DictItemQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...DictItemPaginateOption,
) (*DictItemPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewDictItemPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &DictItemPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*DictItem{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultDictItemOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query dictitem: %w", err)
	}

	ret.List = list
	return ret, nil
}

// DictTypePager provides pagination functionality for DictType
type DictTypePager struct {
	Order  dicttype.OrderOption
	Filter func(*DictTypeQuery) (*DictTypeQuery, error)
}

// DictTypePaginateOption enables pagination customization.
type DictTypePaginateOption func(*DictTypePager)

// DefaultDictTypeOrder is the default ordering of DictType.
var DefaultDictTypeOrder = Desc(dicttype.FieldID)

// NewDictTypePager creates a new pager with the given options
func NewDictTypePager(opts ...DictTypePaginateOption) (*DictTypePager, error) {
	pager := &DictTypePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultDictTypeOrder
	}
	return pager, nil
}

// WithOrder sets the order option for DictType pagination
func WithDictTypeOrder(order dicttype.OrderOption) DictTypePaginateOption {
	return func(p *DictTypePager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for DictType pagination
func WithDictTypeFilter(filter func(*DictTypeQuery) (*DictTypeQuery, error)) DictTypePaginateOption {
	return func(p *DictTypePager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *DictTypePager) ApplyFilter(query *DictTypeQuery) (*DictTypeQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// DictTypePageList is DictType PageList result.
type DictTypePageList struct {
	List        []*DictType  `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

// Page performs paginated query for DictType
func (_m *DictTypeQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...DictTypePaginateOption,
) (*DictTypePageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewDictTypePager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &DictTypePageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count dicttype: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*DictType{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultDictTypeOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query dicttype: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for DictType
func (_m *DictTypeQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...DictTypePaginateOption,
) (*DictTypePageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewDictTypePager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &DictTypePageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*DictType{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultDictTypeOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query dicttype: %w", err)
	}

	ret.List = list
	return ret, nil
}

// MenuPager provides pagination functionality for Menu
type MenuPager struct {
	Order  menu.OrderOption
	Filter func(*MenuQuery) (*MenuQuery, error)
}

// MenuPaginateOption enables pagination customization.
type MenuPaginateOption func(*MenuPager)

// DefaultMenuOrder is the default ordering of Menu.
var DefaultMenuOrder = Desc(menu.FieldID)

// NewMenuPager creates a new pager with the given options
func NewMenuPager(opts ...MenuPaginateOption) (*MenuPager, error) {
	pager := &MenuPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultMenuOrder
	}
	return pager, nil
}

// WithOrder sets the order option for Menu pagination
func WithMenuOrder(order menu.OrderOption) MenuPaginateOption {
	return func(p *MenuPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for Menu pagination
func WithMenuFilter(filter func(*MenuQuery) (*MenuQuery, error)) MenuPaginateOption {
	return func(p *MenuPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *MenuPager) ApplyFilter(query *MenuQuery) (*MenuQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// MenuPageList is Menu PageList result.
type MenuPageList struct {
	List        []*Menu      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

// Page performs paginated query for Menu
func (_m *MenuQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...MenuPaginateOption,
) (*MenuPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewMenuPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &MenuPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count menu: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*Menu{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultMenuOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query menu: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for Menu
func (_m *MenuQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...MenuPaginateOption,
) (*MenuPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewMenuPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &MenuPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*Menu{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultMenuOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query menu: %w", err)
	}

	ret.List = list
	return ret, nil
}

// OauthProviderPager provides pagination functionality for OauthProvider
type OauthProviderPager struct {
	Order  oauthprovider.OrderOption
	Filter func(*OauthProviderQuery) (*OauthProviderQuery, error)
}

// OauthProviderPaginateOption enables pagination customization.
type OauthProviderPaginateOption func(*OauthProviderPager)

// DefaultOauthProviderOrder is the default ordering of OauthProvider.
var DefaultOauthProviderOrder = Desc(oauthprovider.FieldID)

// NewOauthProviderPager creates a new pager with the given options
func NewOauthProviderPager(opts ...OauthProviderPaginateOption) (*OauthProviderPager, error) {
	pager := &OauthProviderPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultOauthProviderOrder
	}
	return pager, nil
}

// WithOrder sets the order option for OauthProvider pagination
func WithOauthProviderOrder(order oauthprovider.OrderOption) OauthProviderPaginateOption {
	return func(p *OauthProviderPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for OauthProvider pagination
func WithOauthProviderFilter(filter func(*OauthProviderQuery) (*OauthProviderQuery, error)) OauthProviderPaginateOption {
	return func(p *OauthProviderPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *OauthProviderPager) ApplyFilter(query *OauthProviderQuery) (*OauthProviderQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// OauthProviderPageList is OauthProvider PageList result.
type OauthProviderPageList struct {
	List        []*OauthProvider `json:"list"`
	PageDetails *PageDetails     `json:"pageDetails"`
}

// Page performs paginated query for OauthProvider
func (_m *OauthProviderQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...OauthProviderPaginateOption,
) (*OauthProviderPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewOauthProviderPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &OauthProviderPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count oauthprovider: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*OauthProvider{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultOauthProviderOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query oauthprovider: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for OauthProvider
func (_m *OauthProviderQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...OauthProviderPaginateOption,
) (*OauthProviderPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewOauthProviderPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &OauthProviderPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*OauthProvider{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultOauthProviderOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query oauthprovider: %w", err)
	}

	ret.List = list
	return ret, nil
}

// OperationLogPager provides pagination functionality for OperationLog
type OperationLogPager struct {
	Order  operationlog.OrderOption
	Filter func(*OperationLogQuery) (*OperationLogQuery, error)
}

// OperationLogPaginateOption enables pagination customization.
type OperationLogPaginateOption func(*OperationLogPager)

// DefaultOperationLogOrder is the default ordering of OperationLog.
var DefaultOperationLogOrder = Desc(operationlog.FieldID)

// NewOperationLogPager creates a new pager with the given options
func NewOperationLogPager(opts ...OperationLogPaginateOption) (*OperationLogPager, error) {
	pager := &OperationLogPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultOperationLogOrder
	}
	return pager, nil
}

// WithOrder sets the order option for OperationLog pagination
func WithOperationLogOrder(order operationlog.OrderOption) OperationLogPaginateOption {
	return func(p *OperationLogPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for OperationLog pagination
func WithOperationLogFilter(filter func(*OperationLogQuery) (*OperationLogQuery, error)) OperationLogPaginateOption {
	return func(p *OperationLogPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *OperationLogPager) ApplyFilter(query *OperationLogQuery) (*OperationLogQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// OperationLogPageList is OperationLog PageList result.
type OperationLogPageList struct {
	List        []*OperationLog `json:"list"`
	PageDetails *PageDetails    `json:"pageDetails"`
}

// Page performs paginated query for OperationLog
func (_m *OperationLogQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...OperationLogPaginateOption,
) (*OperationLogPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewOperationLogPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &OperationLogPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count operationlog: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*OperationLog{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultOperationLogOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query operationlog: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for OperationLog
func (_m *OperationLogQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...OperationLogPaginateOption,
) (*OperationLogPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewOperationLogPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &OperationLogPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*OperationLog{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultOperationLogOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query operationlog: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PositionPager provides pagination functionality for Position
type PositionPager struct {
	Order  position.OrderOption
	Filter func(*PositionQuery) (*PositionQuery, error)
}

// PositionPaginateOption enables pagination customization.
type PositionPaginateOption func(*PositionPager)

// DefaultPositionOrder is the default ordering of Position.
var DefaultPositionOrder = Desc(position.FieldID)

// NewPositionPager creates a new pager with the given options
func NewPositionPager(opts ...PositionPaginateOption) (*PositionPager, error) {
	pager := &PositionPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultPositionOrder
	}
	return pager, nil
}

// WithOrder sets the order option for Position pagination
func WithPositionOrder(order position.OrderOption) PositionPaginateOption {
	return func(p *PositionPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for Position pagination
func WithPositionFilter(filter func(*PositionQuery) (*PositionQuery, error)) PositionPaginateOption {
	return func(p *PositionPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *PositionPager) ApplyFilter(query *PositionQuery) (*PositionQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// PositionPageList is Position PageList result.
type PositionPageList struct {
	List        []*Position  `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

// Page performs paginated query for Position
func (_m *PositionQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...PositionPaginateOption,
) (*PositionPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewPositionPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &PositionPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count position: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*Position{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultPositionOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query position: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for Position
func (_m *PositionQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...PositionPaginateOption,
) (*PositionPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewPositionPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &PositionPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*Position{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultPositionOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query position: %w", err)
	}

	ret.List = list
	return ret, nil
}

// RolePager provides pagination functionality for Role
type RolePager struct {
	Order  role.OrderOption
	Filter func(*RoleQuery) (*RoleQuery, error)
}

// RolePaginateOption enables pagination customization.
type RolePaginateOption func(*RolePager)

// DefaultRoleOrder is the default ordering of Role.
var DefaultRoleOrder = Desc(role.FieldID)

// NewRolePager creates a new pager with the given options
func NewRolePager(opts ...RolePaginateOption) (*RolePager, error) {
	pager := &RolePager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultRoleOrder
	}
	return pager, nil
}

// WithOrder sets the order option for Role pagination
func WithRoleOrder(order role.OrderOption) RolePaginateOption {
	return func(p *RolePager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for Role pagination
func WithRoleFilter(filter func(*RoleQuery) (*RoleQuery, error)) RolePaginateOption {
	return func(p *RolePager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *RolePager) ApplyFilter(query *RoleQuery) (*RoleQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// RolePageList is Role PageList result.
type RolePageList struct {
	List        []*Role      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

// Page performs paginated query for Role
func (_m *RoleQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...RolePaginateOption,
) (*RolePageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewRolePager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &RolePageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count role: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*Role{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultRoleOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query role: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for Role
func (_m *RoleQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...RolePaginateOption,
) (*RolePageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewRolePager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &RolePageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*Role{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultRoleOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query role: %w", err)
	}

	ret.List = list
	return ret, nil
}

// TokenPager provides pagination functionality for Token
type TokenPager struct {
	Order  token.OrderOption
	Filter func(*TokenQuery) (*TokenQuery, error)
}

// TokenPaginateOption enables pagination customization.
type TokenPaginateOption func(*TokenPager)

// DefaultTokenOrder is the default ordering of Token.
var DefaultTokenOrder = Desc(token.FieldID)

// NewTokenPager creates a new pager with the given options
func NewTokenPager(opts ...TokenPaginateOption) (*TokenPager, error) {
	pager := &TokenPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultTokenOrder
	}
	return pager, nil
}

// WithOrder sets the order option for Token pagination
func WithTokenOrder(order token.OrderOption) TokenPaginateOption {
	return func(p *TokenPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for Token pagination
func WithTokenFilter(filter func(*TokenQuery) (*TokenQuery, error)) TokenPaginateOption {
	return func(p *TokenPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *TokenPager) ApplyFilter(query *TokenQuery) (*TokenQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// TokenPageList is Token PageList result.
type TokenPageList struct {
	List        []*Token     `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

// Page performs paginated query for Token
func (_m *TokenQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...TokenPaginateOption,
) (*TokenPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewTokenPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &TokenPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count token: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*Token{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultTokenOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query token: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for Token
func (_m *TokenQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...TokenPaginateOption,
) (*TokenPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewTokenPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &TokenPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*Token{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultTokenOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query token: %w", err)
	}

	ret.List = list
	return ret, nil
}

// UserPager provides pagination functionality for User
type UserPager struct {
	Order  user.OrderOption
	Filter func(*UserQuery) (*UserQuery, error)
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*UserPager)

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = Desc(user.FieldID)

// NewUserPager creates a new pager with the given options
func NewUserPager(opts ...UserPaginateOption) (*UserPager, error) {
	pager := &UserPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultUserOrder
	}
	return pager, nil
}

// WithOrder sets the order option for User pagination
func WithUserOrder(order user.OrderOption) UserPaginateOption {
	return func(p *UserPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for User pagination
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(p *UserPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *UserPager) ApplyFilter(query *UserQuery) (*UserQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// UserPageList is User PageList result.
type UserPageList struct {
	List        []*User      `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

// Page performs paginated query for User
func (_m *UserQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...UserPaginateOption,
) (*UserPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewUserPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &UserPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count user: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*User{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultUserOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query user: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for User
func (_m *UserQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...UserPaginateOption,
) (*UserPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewUserPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &UserPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*User{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultUserOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query user: %w", err)
	}

	ret.List = list
	return ret, nil
}

// UserOauthPager provides pagination functionality for UserOauth
type UserOauthPager struct {
	Order  useroauth.OrderOption
	Filter func(*UserOauthQuery) (*UserOauthQuery, error)
}

// UserOauthPaginateOption enables pagination customization.
type UserOauthPaginateOption func(*UserOauthPager)

// DefaultUserOauthOrder is the default ordering of UserOauth.
var DefaultUserOauthOrder = Desc(useroauth.FieldID)

// NewUserOauthPager creates a new pager with the given options
func NewUserOauthPager(opts ...UserOauthPaginateOption) (*UserOauthPager, error) {
	pager := &UserOauthPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultUserOauthOrder
	}
	return pager, nil
}

// WithOrder sets the order option for UserOauth pagination
func WithUserOauthOrder(order useroauth.OrderOption) UserOauthPaginateOption {
	return func(p *UserOauthPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for UserOauth pagination
func WithUserOauthFilter(filter func(*UserOauthQuery) (*UserOauthQuery, error)) UserOauthPaginateOption {
	return func(p *UserOauthPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *UserOauthPager) ApplyFilter(query *UserOauthQuery) (*UserOauthQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// UserOauthPageList is UserOauth PageList result.
type UserOauthPageList struct {
	List        []*UserOauth `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

// Page performs paginated query for UserOauth
func (_m *UserOauthQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...UserOauthPaginateOption,
) (*UserOauthPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewUserOauthPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &UserOauthPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count useroauth: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*UserOauth{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultUserOauthOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query useroauth: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for UserOauth
func (_m *UserOauthQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...UserOauthPaginateOption,
) (*UserOauthPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewUserOauthPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &UserOauthPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*UserOauth{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultUserOauthOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query useroauth: %w", err)
	}

	ret.List = list
	return ret, nil
}

// UserTotpPager provides pagination functionality for UserTotp
type UserTotpPager struct {
	Order  usertotp.OrderOption
	Filter func(*UserTotpQuery) (*UserTotpQuery, error)
}

// UserTotpPaginateOption enables pagination customization.
type UserTotpPaginateOption func(*UserTotpPager)

// DefaultUserTotpOrder is the default ordering of UserTotp.
var DefaultUserTotpOrder = Desc(usertotp.FieldID)

// NewUserTotpPager creates a new pager with the given options
func NewUserTotpPager(opts ...UserTotpPaginateOption) (*UserTotpPager, error) {
	pager := &UserTotpPager{}
	for _, opt := range opts {
		opt(pager)
	}
	if pager.Order == nil {
		pager.Order = DefaultUserTotpOrder
	}
	return pager, nil
}

// WithOrder sets the order option for UserTotp pagination
func WithUserTotpOrder(order usertotp.OrderOption) UserTotpPaginateOption {
	return func(p *UserTotpPager) {
		p.Order = order
	}
}

// WithFilter sets the filter function for UserTotp pagination
func WithUserTotpFilter(filter func(*UserTotpQuery) (*UserTotpQuery, error)) UserTotpPaginateOption {
	return func(p *UserTotpPager) {
		p.Filter = filter
	}
}

// ApplyFilter applies the filter to the query if set
func (p *UserTotpPager) ApplyFilter(query *UserTotpQuery) (*UserTotpQuery, error) {
	if p.Filter != nil {
		return p.Filter(query)
	}
	return query, nil
}

// UserTotpPageList is UserTotp PageList result.
type UserTotpPageList struct {
	List        []*UserTotp  `json:"list"`
	PageDetails *PageDetails `json:"pageDetails"`
}

// Page performs paginated query for UserTotp
func (_m *UserTotpQuery) Page(
	ctx context.Context, pageNum uint32, pageSize uint32, opts ...UserTotpPaginateOption,
) (*UserTotpPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewUserTotpPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &UserTotpPageList{}
	ret.PageDetails = &PageDetails{
		Page: pageNum,
		Size: pageSize,
	}

	// Get total count
	countQuery := _m.Clone()
	countQuery.ctx.Fields = nil
	count, err := countQuery.Count(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count usertotp: %w", err)
	}

	ret.PageDetails.Total = uint64(count)
	ret.PageDetails.Pages = CalculatePages(ret.PageDetails.Total, pageSize)

	// If no records, return empty list
	if count == 0 {
		ret.List = []*UserTotp{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultUserTotpOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query usertotp: %w", err)
	}

	ret.List = list
	return ret, nil
}

// PageWithCount performs paginated query with pre-calculated count for UserTotp
func (_m *UserTotpQuery) PageWithCount(
	ctx context.Context, pageNum uint32, pageSize uint32, totalCount uint64, opts ...UserTotpPaginateOption,
) (*UserTotpPageList, error) {
	// Validate pagination parameters
	if err := ValidatePageParams(pageNum, pageSize); err != nil {
		return nil, err
	}

	// Create pager with options
	pager, err := NewUserTotpPager(opts...)
	if err != nil {
		return nil, err
	}

	// Apply filter if set
	if _m, err = pager.ApplyFilter(_m); err != nil {
		return nil, err
	}

	ret := &UserTotpPageList{}
	ret.PageDetails = &PageDetails{
		Page:  pageNum,
		Size:  pageSize,
		Total: totalCount,
		Pages: CalculatePages(totalCount, pageSize),
	}

	// If no records, return empty list
	if totalCount == 0 {
		ret.List = []*UserTotp{}
		return ret, nil
	}

	// Apply ordering
	if pager.Order != nil {
		_m = _m.Order(pager.Order)
	} else {
		_m = _m.Order(DefaultUserTotpOrder)
	}

	// Apply pagination
	offset := CalculateOffset(pageNum, pageSize)
	_m = _m.Offset(offset).Limit(int(pageSize))

	list, err := _m.All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query usertotp: %w", err)
	}

	ret.List = list
	return ret, nil
}
