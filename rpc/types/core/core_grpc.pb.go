// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v4.25.2
// source: rpc/core.proto

package core

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	ApiService_CreateOrUpdateApi_FullMethodName = "/core.ApiService/CreateOrUpdateApi"
	ApiService_DeleteApi_FullMethodName         = "/core.ApiService/DeleteApi"
	ApiService_GetApi_FullMethodName            = "/core.ApiService/GetApi"
	ApiService_ListApi_FullMethodName           = "/core.ApiService/ListApi"
)

// ApiServiceClient is the client API for ApiService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiServiceClient interface {
	// 创建或更新API
	CreateOrUpdateApi(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*ApiInfo, error)
	// 删除API
	DeleteApi(ctx context.Context, in *ID32SRequest, opts ...grpc.CallOption) (*BaseResponse, error)
	// 获取API
	GetApi(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*ApiInfo, error)
	// 获取API列表
	ListApi(ctx context.Context, in *ApiListRequest, opts ...grpc.CallOption) (*ApiListResponse, error)
}

type apiServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewApiServiceClient(cc grpc.ClientConnInterface) ApiServiceClient {
	return &apiServiceClient{cc}
}

func (c *apiServiceClient) CreateOrUpdateApi(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*ApiInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApiInfo)
	err := c.cc.Invoke(ctx, ApiService_CreateOrUpdateApi_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) DeleteApi(ctx context.Context, in *ID32SRequest, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, ApiService_DeleteApi_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) GetApi(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*ApiInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApiInfo)
	err := c.cc.Invoke(ctx, ApiService_GetApi_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiServiceClient) ListApi(ctx context.Context, in *ApiListRequest, opts ...grpc.CallOption) (*ApiListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ApiListResponse)
	err := c.cc.Invoke(ctx, ApiService_ListApi_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiServiceServer is the server API for ApiService service.
// All implementations must embed UnimplementedApiServiceServer
// for forward compatibility
type ApiServiceServer interface {
	// 创建或更新API
	CreateOrUpdateApi(context.Context, *ApiInfo) (*ApiInfo, error)
	// 删除API
	DeleteApi(context.Context, *ID32SRequest) (*BaseResponse, error)
	// 获取API
	GetApi(context.Context, *ID32Request) (*ApiInfo, error)
	// 获取API列表
	ListApi(context.Context, *ApiListRequest) (*ApiListResponse, error)
	mustEmbedUnimplementedApiServiceServer()
}

// UnimplementedApiServiceServer must be embedded to have forward compatible implementations.
type UnimplementedApiServiceServer struct {
}

func (UnimplementedApiServiceServer) CreateOrUpdateApi(context.Context, *ApiInfo) (*ApiInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdateApi not implemented")
}
func (UnimplementedApiServiceServer) DeleteApi(context.Context, *ID32SRequest) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteApi not implemented")
}
func (UnimplementedApiServiceServer) GetApi(context.Context, *ID32Request) (*ApiInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetApi not implemented")
}
func (UnimplementedApiServiceServer) ListApi(context.Context, *ApiListRequest) (*ApiListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListApi not implemented")
}
func (UnimplementedApiServiceServer) mustEmbedUnimplementedApiServiceServer() {}

// UnsafeApiServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiServiceServer will
// result in compilation errors.
type UnsafeApiServiceServer interface {
	mustEmbedUnimplementedApiServiceServer()
}

func RegisterApiServiceServer(s grpc.ServiceRegistrar, srv ApiServiceServer) {
	s.RegisterService(&ApiService_ServiceDesc, srv)
}

func _ApiService_CreateOrUpdateApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).CreateOrUpdateApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiService_CreateOrUpdateApi_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).CreateOrUpdateApi(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_DeleteApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32SRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).DeleteApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiService_DeleteApi_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).DeleteApi(ctx, req.(*ID32SRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_GetApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).GetApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiService_GetApi_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).GetApi(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiService_ListApi_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServiceServer).ListApi(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiService_ListApi_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServiceServer).ListApi(ctx, req.(*ApiListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ApiService_ServiceDesc is the grpc.ServiceDesc for ApiService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ApiService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.ApiService",
	HandlerType: (*ApiServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrUpdateApi",
			Handler:    _ApiService_CreateOrUpdateApi_Handler,
		},
		{
			MethodName: "DeleteApi",
			Handler:    _ApiService_DeleteApi_Handler,
		},
		{
			MethodName: "GetApi",
			Handler:    _ApiService_GetApi_Handler,
		},
		{
			MethodName: "ListApi",
			Handler:    _ApiService_ListApi_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/core.proto",
}

const (
	DictService_CreateOrUpdateDict_FullMethodName     = "/core.DictService/CreateOrUpdateDict"
	DictService_DeleteDict_FullMethodName             = "/core.DictService/DeleteDict"
	DictService_GetDict_FullMethodName                = "/core.DictService/GetDict"
	DictService_ListDict_FullMethodName               = "/core.DictService/ListDict"
	DictService_CreateOrUpdateDictItem_FullMethodName = "/core.DictService/CreateOrUpdateDictItem"
	DictService_DeleteDictItem_FullMethodName         = "/core.DictService/DeleteDictItem"
	DictService_GetDictItem_FullMethodName            = "/core.DictService/GetDictItem"
	DictService_ListDictItem_FullMethodName           = "/core.DictService/ListDictItem"
)

// DictServiceClient is the client API for DictService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DictServiceClient interface {
	// 创建或更新字典
	CreateOrUpdateDict(ctx context.Context, in *DictInfo, opts ...grpc.CallOption) (*DictInfo, error)
	// 删除字典
	DeleteDict(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error)
	// 获取字典
	GetDict(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*DictInfo, error)
	// 获取字典列表
	ListDict(ctx context.Context, in *DictListRequest, opts ...grpc.CallOption) (*DictListResponse, error)
	// 创建或更新字典子项
	CreateOrUpdateDictItem(ctx context.Context, in *DictItemInfo, opts ...grpc.CallOption) (*DictItemInfo, error)
	// 删除字典子项
	DeleteDictItem(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error)
	// 获取字典子项
	GetDictItem(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*DictItemInfo, error)
	// 获取字典子项列表
	ListDictItem(ctx context.Context, in *DictItemListRequest, opts ...grpc.CallOption) (*DictItemListResponse, error)
}

type dictServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDictServiceClient(cc grpc.ClientConnInterface) DictServiceClient {
	return &dictServiceClient{cc}
}

func (c *dictServiceClient) CreateOrUpdateDict(ctx context.Context, in *DictInfo, opts ...grpc.CallOption) (*DictInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DictInfo)
	err := c.cc.Invoke(ctx, DictService_CreateOrUpdateDict_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictServiceClient) DeleteDict(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, DictService_DeleteDict_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictServiceClient) GetDict(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*DictInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DictInfo)
	err := c.cc.Invoke(ctx, DictService_GetDict_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictServiceClient) ListDict(ctx context.Context, in *DictListRequest, opts ...grpc.CallOption) (*DictListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DictListResponse)
	err := c.cc.Invoke(ctx, DictService_ListDict_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictServiceClient) CreateOrUpdateDictItem(ctx context.Context, in *DictItemInfo, opts ...grpc.CallOption) (*DictItemInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DictItemInfo)
	err := c.cc.Invoke(ctx, DictService_CreateOrUpdateDictItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictServiceClient) DeleteDictItem(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, DictService_DeleteDictItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictServiceClient) GetDictItem(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*DictItemInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DictItemInfo)
	err := c.cc.Invoke(ctx, DictService_GetDictItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dictServiceClient) ListDictItem(ctx context.Context, in *DictItemListRequest, opts ...grpc.CallOption) (*DictItemListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DictItemListResponse)
	err := c.cc.Invoke(ctx, DictService_ListDictItem_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DictServiceServer is the server API for DictService service.
// All implementations must embed UnimplementedDictServiceServer
// for forward compatibility
type DictServiceServer interface {
	// 创建或更新字典
	CreateOrUpdateDict(context.Context, *DictInfo) (*DictInfo, error)
	// 删除字典
	DeleteDict(context.Context, *ID32Request) (*BaseResponse, error)
	// 获取字典
	GetDict(context.Context, *ID32Request) (*DictInfo, error)
	// 获取字典列表
	ListDict(context.Context, *DictListRequest) (*DictListResponse, error)
	// 创建或更新字典子项
	CreateOrUpdateDictItem(context.Context, *DictItemInfo) (*DictItemInfo, error)
	// 删除字典子项
	DeleteDictItem(context.Context, *ID32Request) (*BaseResponse, error)
	// 获取字典子项
	GetDictItem(context.Context, *ID32Request) (*DictItemInfo, error)
	// 获取字典子项列表
	ListDictItem(context.Context, *DictItemListRequest) (*DictItemListResponse, error)
	mustEmbedUnimplementedDictServiceServer()
}

// UnimplementedDictServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDictServiceServer struct {
}

func (UnimplementedDictServiceServer) CreateOrUpdateDict(context.Context, *DictInfo) (*DictInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdateDict not implemented")
}
func (UnimplementedDictServiceServer) DeleteDict(context.Context, *ID32Request) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDict not implemented")
}
func (UnimplementedDictServiceServer) GetDict(context.Context, *ID32Request) (*DictInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDict not implemented")
}
func (UnimplementedDictServiceServer) ListDict(context.Context, *DictListRequest) (*DictListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDict not implemented")
}
func (UnimplementedDictServiceServer) CreateOrUpdateDictItem(context.Context, *DictItemInfo) (*DictItemInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdateDictItem not implemented")
}
func (UnimplementedDictServiceServer) DeleteDictItem(context.Context, *ID32Request) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDictItem not implemented")
}
func (UnimplementedDictServiceServer) GetDictItem(context.Context, *ID32Request) (*DictItemInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDictItem not implemented")
}
func (UnimplementedDictServiceServer) ListDictItem(context.Context, *DictItemListRequest) (*DictItemListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDictItem not implemented")
}
func (UnimplementedDictServiceServer) mustEmbedUnimplementedDictServiceServer() {}

// UnsafeDictServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DictServiceServer will
// result in compilation errors.
type UnsafeDictServiceServer interface {
	mustEmbedUnimplementedDictServiceServer()
}

func RegisterDictServiceServer(s grpc.ServiceRegistrar, srv DictServiceServer) {
	s.RegisterService(&DictService_ServiceDesc, srv)
}

func _DictService_CreateOrUpdateDict_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DictInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictServiceServer).CreateOrUpdateDict(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictService_CreateOrUpdateDict_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictServiceServer).CreateOrUpdateDict(ctx, req.(*DictInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictService_DeleteDict_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictServiceServer).DeleteDict(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictService_DeleteDict_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictServiceServer).DeleteDict(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictService_GetDict_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictServiceServer).GetDict(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictService_GetDict_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictServiceServer).GetDict(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictService_ListDict_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DictListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictServiceServer).ListDict(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictService_ListDict_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictServiceServer).ListDict(ctx, req.(*DictListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictService_CreateOrUpdateDictItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DictItemInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictServiceServer).CreateOrUpdateDictItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictService_CreateOrUpdateDictItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictServiceServer).CreateOrUpdateDictItem(ctx, req.(*DictItemInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictService_DeleteDictItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictServiceServer).DeleteDictItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictService_DeleteDictItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictServiceServer).DeleteDictItem(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictService_GetDictItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictServiceServer).GetDictItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictService_GetDictItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictServiceServer).GetDictItem(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _DictService_ListDictItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DictItemListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DictServiceServer).ListDictItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DictService_ListDictItem_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DictServiceServer).ListDictItem(ctx, req.(*DictItemListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DictService_ServiceDesc is the grpc.ServiceDesc for DictService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DictService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.DictService",
	HandlerType: (*DictServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrUpdateDict",
			Handler:    _DictService_CreateOrUpdateDict_Handler,
		},
		{
			MethodName: "DeleteDict",
			Handler:    _DictService_DeleteDict_Handler,
		},
		{
			MethodName: "GetDict",
			Handler:    _DictService_GetDict_Handler,
		},
		{
			MethodName: "ListDict",
			Handler:    _DictService_ListDict_Handler,
		},
		{
			MethodName: "CreateOrUpdateDictItem",
			Handler:    _DictService_CreateOrUpdateDictItem_Handler,
		},
		{
			MethodName: "DeleteDictItem",
			Handler:    _DictService_DeleteDictItem_Handler,
		},
		{
			MethodName: "GetDictItem",
			Handler:    _DictService_GetDictItem_Handler,
		},
		{
			MethodName: "ListDictItem",
			Handler:    _DictService_ListDictItem_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/core.proto",
}

const (
	RoleService_CreateOrUpdateRole_FullMethodName = "/core.RoleService/CreateOrUpdateRole"
	RoleService_DeleteRole_FullMethodName         = "/core.RoleService/DeleteRole"
	RoleService_GetRole_FullMethodName            = "/core.RoleService/GetRole"
	RoleService_ListRole_FullMethodName           = "/core.RoleService/ListRole"
	RoleService_GetRoleByValue_FullMethodName     = "/core.RoleService/GetRoleByValue"
)

// RoleServiceClient is the client API for RoleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleServiceClient interface {
	// 创建或更新角色
	CreateOrUpdateRole(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*RoleInfo, error)
	// 删除角色
	DeleteRole(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error)
	// 获取角色
	GetRole(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*RoleInfo, error)
	// 获取角色列表
	ListRole(ctx context.Context, in *RoleListRequest, opts ...grpc.CallOption) (*RoleListResponse, error)
	// 通过值获取角色
	GetRoleByValue(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*RoleInfo, error)
}

type roleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleServiceClient(cc grpc.ClientConnInterface) RoleServiceClient {
	return &roleServiceClient{cc}
}

func (c *roleServiceClient) CreateOrUpdateRole(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*RoleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleInfo)
	err := c.cc.Invoke(ctx, RoleService_CreateOrUpdateRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) DeleteRole(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, RoleService_DeleteRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) GetRole(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*RoleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleInfo)
	err := c.cc.Invoke(ctx, RoleService_GetRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) ListRole(ctx context.Context, in *RoleListRequest, opts ...grpc.CallOption) (*RoleListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleListResponse)
	err := c.cc.Invoke(ctx, RoleService_ListRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleServiceClient) GetRoleByValue(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*RoleInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RoleInfo)
	err := c.cc.Invoke(ctx, RoleService_GetRoleByValue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServiceServer is the server API for RoleService service.
// All implementations must embed UnimplementedRoleServiceServer
// for forward compatibility
type RoleServiceServer interface {
	// 创建或更新角色
	CreateOrUpdateRole(context.Context, *RoleInfo) (*RoleInfo, error)
	// 删除角色
	DeleteRole(context.Context, *ID32Request) (*BaseResponse, error)
	// 获取角色
	GetRole(context.Context, *ID32Request) (*RoleInfo, error)
	// 获取角色列表
	ListRole(context.Context, *RoleListRequest) (*RoleListResponse, error)
	// 通过值获取角色
	GetRoleByValue(context.Context, *StringRequest) (*RoleInfo, error)
	mustEmbedUnimplementedRoleServiceServer()
}

// UnimplementedRoleServiceServer must be embedded to have forward compatible implementations.
type UnimplementedRoleServiceServer struct {
}

func (UnimplementedRoleServiceServer) CreateOrUpdateRole(context.Context, *RoleInfo) (*RoleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdateRole not implemented")
}
func (UnimplementedRoleServiceServer) DeleteRole(context.Context, *ID32Request) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRole not implemented")
}
func (UnimplementedRoleServiceServer) GetRole(context.Context, *ID32Request) (*RoleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRole not implemented")
}
func (UnimplementedRoleServiceServer) ListRole(context.Context, *RoleListRequest) (*RoleListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRole not implemented")
}
func (UnimplementedRoleServiceServer) GetRoleByValue(context.Context, *StringRequest) (*RoleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoleByValue not implemented")
}
func (UnimplementedRoleServiceServer) mustEmbedUnimplementedRoleServiceServer() {}

// UnsafeRoleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServiceServer will
// result in compilation errors.
type UnsafeRoleServiceServer interface {
	mustEmbedUnimplementedRoleServiceServer()
}

func RegisterRoleServiceServer(s grpc.ServiceRegistrar, srv RoleServiceServer) {
	s.RegisterService(&RoleService_ServiceDesc, srv)
}

func _RoleService_CreateOrUpdateRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).CreateOrUpdateRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_CreateOrUpdateRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).CreateOrUpdateRole(ctx, req.(*RoleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_DeleteRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).DeleteRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_DeleteRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).DeleteRole(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_GetRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).GetRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_GetRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).GetRole(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_ListRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).ListRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_ListRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).ListRole(ctx, req.(*RoleListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleService_GetRoleByValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServiceServer).GetRoleByValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleService_GetRoleByValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServiceServer).GetRoleByValue(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RoleService_ServiceDesc is the grpc.ServiceDesc for RoleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.RoleService",
	HandlerType: (*RoleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrUpdateRole",
			Handler:    _RoleService_CreateOrUpdateRole_Handler,
		},
		{
			MethodName: "DeleteRole",
			Handler:    _RoleService_DeleteRole_Handler,
		},
		{
			MethodName: "GetRole",
			Handler:    _RoleService_GetRole_Handler,
		},
		{
			MethodName: "ListRole",
			Handler:    _RoleService_ListRole_Handler,
		},
		{
			MethodName: "GetRoleByValue",
			Handler:    _RoleService_GetRoleByValue_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/core.proto",
}

const (
	MenuService_CreateOrUpdateMenu_FullMethodName       = "/core.MenuService/CreateOrUpdateMenu"
	MenuService_DeleteMenu_FullMethodName               = "/core.MenuService/DeleteMenu"
	MenuService_GetMenu_FullMethodName                  = "/core.MenuService/GetMenu"
	MenuService_ListMenu_FullMethodName                 = "/core.MenuService/ListMenu"
	MenuService_ListMenuByRole_FullMethodName           = "/core.MenuService/ListMenuByRole"
	MenuService_ListPagePermissionByRole_FullMethodName = "/core.MenuService/ListPagePermissionByRole"
)

// MenuServiceClient is the client API for MenuService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuServiceClient interface {
	// 创建或更新菜单
	CreateOrUpdateMenu(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*MenuInfo, error)
	// 删除菜单
	DeleteMenu(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error)
	// 获取菜单
	GetMenu(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*MenuInfo, error)
	// 获取菜单列表
	ListMenu(ctx context.Context, in *MenuListRequest, opts ...grpc.CallOption) (*MenuListResponse, error)
	// 通过角色查询菜单
	ListMenuByRole(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*MenuListResponse, error)
	// 获取角色对应的所有页面权限
	ListPagePermissionByRole(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*StringListResponse, error)
}

type menuServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuServiceClient(cc grpc.ClientConnInterface) MenuServiceClient {
	return &menuServiceClient{cc}
}

func (c *menuServiceClient) CreateOrUpdateMenu(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*MenuInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuInfo)
	err := c.cc.Invoke(ctx, MenuService_CreateOrUpdateMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) DeleteMenu(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, MenuService_DeleteMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) GetMenu(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*MenuInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuInfo)
	err := c.cc.Invoke(ctx, MenuService_GetMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) ListMenu(ctx context.Context, in *MenuListRequest, opts ...grpc.CallOption) (*MenuListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuListResponse)
	err := c.cc.Invoke(ctx, MenuService_ListMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) ListMenuByRole(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*MenuListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MenuListResponse)
	err := c.cc.Invoke(ctx, MenuService_ListMenuByRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuServiceClient) ListPagePermissionByRole(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*StringListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StringListResponse)
	err := c.cc.Invoke(ctx, MenuService_ListPagePermissionByRole_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuServiceServer is the server API for MenuService service.
// All implementations must embed UnimplementedMenuServiceServer
// for forward compatibility
type MenuServiceServer interface {
	// 创建或更新菜单
	CreateOrUpdateMenu(context.Context, *MenuInfo) (*MenuInfo, error)
	// 删除菜单
	DeleteMenu(context.Context, *ID32Request) (*BaseResponse, error)
	// 获取菜单
	GetMenu(context.Context, *ID32Request) (*MenuInfo, error)
	// 获取菜单列表
	ListMenu(context.Context, *MenuListRequest) (*MenuListResponse, error)
	// 通过角色查询菜单
	ListMenuByRole(context.Context, *StringRequest) (*MenuListResponse, error)
	// 获取角色对应的所有页面权限
	ListPagePermissionByRole(context.Context, *StringRequest) (*StringListResponse, error)
	mustEmbedUnimplementedMenuServiceServer()
}

// UnimplementedMenuServiceServer must be embedded to have forward compatible implementations.
type UnimplementedMenuServiceServer struct {
}

func (UnimplementedMenuServiceServer) CreateOrUpdateMenu(context.Context, *MenuInfo) (*MenuInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdateMenu not implemented")
}
func (UnimplementedMenuServiceServer) DeleteMenu(context.Context, *ID32Request) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMenu not implemented")
}
func (UnimplementedMenuServiceServer) GetMenu(context.Context, *ID32Request) (*MenuInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMenu not implemented")
}
func (UnimplementedMenuServiceServer) ListMenu(context.Context, *MenuListRequest) (*MenuListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMenu not implemented")
}
func (UnimplementedMenuServiceServer) ListMenuByRole(context.Context, *StringRequest) (*MenuListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMenuByRole not implemented")
}
func (UnimplementedMenuServiceServer) ListPagePermissionByRole(context.Context, *StringRequest) (*StringListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPagePermissionByRole not implemented")
}
func (UnimplementedMenuServiceServer) mustEmbedUnimplementedMenuServiceServer() {}

// UnsafeMenuServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuServiceServer will
// result in compilation errors.
type UnsafeMenuServiceServer interface {
	mustEmbedUnimplementedMenuServiceServer()
}

func RegisterMenuServiceServer(s grpc.ServiceRegistrar, srv MenuServiceServer) {
	s.RegisterService(&MenuService_ServiceDesc, srv)
}

func _MenuService_CreateOrUpdateMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).CreateOrUpdateMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_CreateOrUpdateMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).CreateOrUpdateMenu(ctx, req.(*MenuInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_DeleteMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).DeleteMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_DeleteMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).DeleteMenu(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_GetMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).GetMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_GetMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).GetMenu(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_ListMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).ListMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_ListMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).ListMenu(ctx, req.(*MenuListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_ListMenuByRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).ListMenuByRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_ListMenuByRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).ListMenuByRole(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuService_ListPagePermissionByRole_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServiceServer).ListPagePermissionByRole(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuService_ListPagePermissionByRole_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServiceServer).ListPagePermissionByRole(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MenuService_ServiceDesc is the grpc.ServiceDesc for MenuService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MenuService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.MenuService",
	HandlerType: (*MenuServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrUpdateMenu",
			Handler:    _MenuService_CreateOrUpdateMenu_Handler,
		},
		{
			MethodName: "DeleteMenu",
			Handler:    _MenuService_DeleteMenu_Handler,
		},
		{
			MethodName: "GetMenu",
			Handler:    _MenuService_GetMenu_Handler,
		},
		{
			MethodName: "ListMenu",
			Handler:    _MenuService_ListMenu_Handler,
		},
		{
			MethodName: "ListMenuByRole",
			Handler:    _MenuService_ListMenuByRole_Handler,
		},
		{
			MethodName: "ListPagePermissionByRole",
			Handler:    _MenuService_ListPagePermissionByRole_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/core.proto",
}

const (
	DepartmentService_CreateOrUpdateDepartment_FullMethodName = "/core.DepartmentService/CreateOrUpdateDepartment"
	DepartmentService_DeleteDepartment_FullMethodName         = "/core.DepartmentService/DeleteDepartment"
	DepartmentService_GetDepartment_FullMethodName            = "/core.DepartmentService/GetDepartment"
	DepartmentService_ListDepartment_FullMethodName           = "/core.DepartmentService/ListDepartment"
)

// DepartmentServiceClient is the client API for DepartmentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DepartmentServiceClient interface {
	// 创建或更新部门
	CreateOrUpdateDepartment(ctx context.Context, in *DepartmentInfo, opts ...grpc.CallOption) (*DepartmentInfo, error)
	// 删除部门
	DeleteDepartment(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error)
	// 获取部门
	GetDepartment(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*DepartmentInfo, error)
	// 获取部门列表
	ListDepartment(ctx context.Context, in *DepartmentListRequest, opts ...grpc.CallOption) (*DepartmentListResponse, error)
}

type departmentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDepartmentServiceClient(cc grpc.ClientConnInterface) DepartmentServiceClient {
	return &departmentServiceClient{cc}
}

func (c *departmentServiceClient) CreateOrUpdateDepartment(ctx context.Context, in *DepartmentInfo, opts ...grpc.CallOption) (*DepartmentInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DepartmentInfo)
	err := c.cc.Invoke(ctx, DepartmentService_CreateOrUpdateDepartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentServiceClient) DeleteDepartment(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, DepartmentService_DeleteDepartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentServiceClient) GetDepartment(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*DepartmentInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DepartmentInfo)
	err := c.cc.Invoke(ctx, DepartmentService_GetDepartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *departmentServiceClient) ListDepartment(ctx context.Context, in *DepartmentListRequest, opts ...grpc.CallOption) (*DepartmentListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DepartmentListResponse)
	err := c.cc.Invoke(ctx, DepartmentService_ListDepartment_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DepartmentServiceServer is the server API for DepartmentService service.
// All implementations must embed UnimplementedDepartmentServiceServer
// for forward compatibility
type DepartmentServiceServer interface {
	// 创建或更新部门
	CreateOrUpdateDepartment(context.Context, *DepartmentInfo) (*DepartmentInfo, error)
	// 删除部门
	DeleteDepartment(context.Context, *ID32Request) (*BaseResponse, error)
	// 获取部门
	GetDepartment(context.Context, *ID32Request) (*DepartmentInfo, error)
	// 获取部门列表
	ListDepartment(context.Context, *DepartmentListRequest) (*DepartmentListResponse, error)
	mustEmbedUnimplementedDepartmentServiceServer()
}

// UnimplementedDepartmentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDepartmentServiceServer struct {
}

func (UnimplementedDepartmentServiceServer) CreateOrUpdateDepartment(context.Context, *DepartmentInfo) (*DepartmentInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdateDepartment not implemented")
}
func (UnimplementedDepartmentServiceServer) DeleteDepartment(context.Context, *ID32Request) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteDepartment not implemented")
}
func (UnimplementedDepartmentServiceServer) GetDepartment(context.Context, *ID32Request) (*DepartmentInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDepartment not implemented")
}
func (UnimplementedDepartmentServiceServer) ListDepartment(context.Context, *DepartmentListRequest) (*DepartmentListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDepartment not implemented")
}
func (UnimplementedDepartmentServiceServer) mustEmbedUnimplementedDepartmentServiceServer() {}

// UnsafeDepartmentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DepartmentServiceServer will
// result in compilation errors.
type UnsafeDepartmentServiceServer interface {
	mustEmbedUnimplementedDepartmentServiceServer()
}

func RegisterDepartmentServiceServer(s grpc.ServiceRegistrar, srv DepartmentServiceServer) {
	s.RegisterService(&DepartmentService_ServiceDesc, srv)
}

func _DepartmentService_CreateOrUpdateDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepartmentInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServiceServer).CreateOrUpdateDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentService_CreateOrUpdateDepartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServiceServer).CreateOrUpdateDepartment(ctx, req.(*DepartmentInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _DepartmentService_DeleteDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServiceServer).DeleteDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentService_DeleteDepartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServiceServer).DeleteDepartment(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _DepartmentService_GetDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServiceServer).GetDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentService_GetDepartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServiceServer).GetDepartment(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _DepartmentService_ListDepartment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DepartmentListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DepartmentServiceServer).ListDepartment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DepartmentService_ListDepartment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DepartmentServiceServer).ListDepartment(ctx, req.(*DepartmentListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DepartmentService_ServiceDesc is the grpc.ServiceDesc for DepartmentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DepartmentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.DepartmentService",
	HandlerType: (*DepartmentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrUpdateDepartment",
			Handler:    _DepartmentService_CreateOrUpdateDepartment_Handler,
		},
		{
			MethodName: "DeleteDepartment",
			Handler:    _DepartmentService_DeleteDepartment_Handler,
		},
		{
			MethodName: "GetDepartment",
			Handler:    _DepartmentService_GetDepartment_Handler,
		},
		{
			MethodName: "ListDepartment",
			Handler:    _DepartmentService_ListDepartment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/core.proto",
}

const (
	PositionService_CreateOrUpdatePosition_FullMethodName = "/core.PositionService/CreateOrUpdatePosition"
	PositionService_DeletePosition_FullMethodName         = "/core.PositionService/DeletePosition"
	PositionService_GetPosition_FullMethodName            = "/core.PositionService/GetPosition"
	PositionService_ListPosition_FullMethodName           = "/core.PositionService/ListPosition"
)

// PositionServiceClient is the client API for PositionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PositionServiceClient interface {
	// 创建或更新岗位
	CreateOrUpdatePosition(ctx context.Context, in *PositionInfo, opts ...grpc.CallOption) (*PositionInfo, error)
	// 删除岗位
	DeletePosition(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error)
	// 获取岗位
	GetPosition(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*PositionInfo, error)
	// 获取岗位列表
	ListPosition(ctx context.Context, in *PositionListRequest, opts ...grpc.CallOption) (*PositionListResponse, error)
}

type positionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPositionServiceClient(cc grpc.ClientConnInterface) PositionServiceClient {
	return &positionServiceClient{cc}
}

func (c *positionServiceClient) CreateOrUpdatePosition(ctx context.Context, in *PositionInfo, opts ...grpc.CallOption) (*PositionInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PositionInfo)
	err := c.cc.Invoke(ctx, PositionService_CreateOrUpdatePosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *positionServiceClient) DeletePosition(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, PositionService_DeletePosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *positionServiceClient) GetPosition(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*PositionInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PositionInfo)
	err := c.cc.Invoke(ctx, PositionService_GetPosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *positionServiceClient) ListPosition(ctx context.Context, in *PositionListRequest, opts ...grpc.CallOption) (*PositionListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PositionListResponse)
	err := c.cc.Invoke(ctx, PositionService_ListPosition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PositionServiceServer is the server API for PositionService service.
// All implementations must embed UnimplementedPositionServiceServer
// for forward compatibility
type PositionServiceServer interface {
	// 创建或更新岗位
	CreateOrUpdatePosition(context.Context, *PositionInfo) (*PositionInfo, error)
	// 删除岗位
	DeletePosition(context.Context, *ID32Request) (*BaseResponse, error)
	// 获取岗位
	GetPosition(context.Context, *ID32Request) (*PositionInfo, error)
	// 获取岗位列表
	ListPosition(context.Context, *PositionListRequest) (*PositionListResponse, error)
	mustEmbedUnimplementedPositionServiceServer()
}

// UnimplementedPositionServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPositionServiceServer struct {
}

func (UnimplementedPositionServiceServer) CreateOrUpdatePosition(context.Context, *PositionInfo) (*PositionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdatePosition not implemented")
}
func (UnimplementedPositionServiceServer) DeletePosition(context.Context, *ID32Request) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePosition not implemented")
}
func (UnimplementedPositionServiceServer) GetPosition(context.Context, *ID32Request) (*PositionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPosition not implemented")
}
func (UnimplementedPositionServiceServer) ListPosition(context.Context, *PositionListRequest) (*PositionListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPosition not implemented")
}
func (UnimplementedPositionServiceServer) mustEmbedUnimplementedPositionServiceServer() {}

// UnsafePositionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PositionServiceServer will
// result in compilation errors.
type UnsafePositionServiceServer interface {
	mustEmbedUnimplementedPositionServiceServer()
}

func RegisterPositionServiceServer(s grpc.ServiceRegistrar, srv PositionServiceServer) {
	s.RegisterService(&PositionService_ServiceDesc, srv)
}

func _PositionService_CreateOrUpdatePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PositionInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PositionServiceServer).CreateOrUpdatePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PositionService_CreateOrUpdatePosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PositionServiceServer).CreateOrUpdatePosition(ctx, req.(*PositionInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _PositionService_DeletePosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PositionServiceServer).DeletePosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PositionService_DeletePosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PositionServiceServer).DeletePosition(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _PositionService_GetPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PositionServiceServer).GetPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PositionService_GetPosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PositionServiceServer).GetPosition(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _PositionService_ListPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PositionListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PositionServiceServer).ListPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PositionService_ListPosition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PositionServiceServer).ListPosition(ctx, req.(*PositionListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PositionService_ServiceDesc is the grpc.ServiceDesc for PositionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PositionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.PositionService",
	HandlerType: (*PositionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrUpdatePosition",
			Handler:    _PositionService_CreateOrUpdatePosition_Handler,
		},
		{
			MethodName: "DeletePosition",
			Handler:    _PositionService_DeletePosition_Handler,
		},
		{
			MethodName: "GetPosition",
			Handler:    _PositionService_GetPosition_Handler,
		},
		{
			MethodName: "ListPosition",
			Handler:    _PositionService_ListPosition_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/core.proto",
}

const (
	UserService_CreateUser_FullMethodName            = "/core.UserService/CreateUser"
	UserService_UpdateUser_FullMethodName            = "/core.UserService/UpdateUser"
	UserService_DeleteUser_FullMethodName            = "/core.UserService/DeleteUser"
	UserService_GetUser_FullMethodName               = "/core.UserService/GetUser"
	UserService_ListUser_FullMethodName              = "/core.UserService/ListUser"
	UserService_GetUserByUsername_FullMethodName     = "/core.UserService/GetUserByUsername"
	UserService_EnableTotp_FullMethodName            = "/core.UserService/EnableTotp"
	UserService_VerifyTotpSetup_FullMethodName       = "/core.UserService/VerifyTotpSetup"
	UserService_DisableTotp_FullMethodName           = "/core.UserService/DisableTotp"
	UserService_VerifyTotpCode_FullMethodName        = "/core.UserService/VerifyTotpCode"
	UserService_GetTotpStatus_FullMethodName         = "/core.UserService/GetTotpStatus"
	UserService_RegenerateBackupCodes_FullMethodName = "/core.UserService/RegenerateBackupCodes"
	UserService_UseBackupCode_FullMethodName         = "/core.UserService/UseBackupCode"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	// 创建用户
	CreateUser(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*UserInfo, error)
	// 更新用户
	UpdateUser(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*UserInfo, error)
	// 删除用户
	DeleteUser(ctx context.Context, in *UUIDRequest, opts ...grpc.CallOption) (*BaseResponse, error)
	// 获取用户
	GetUser(ctx context.Context, in *UUIDRequest, opts ...grpc.CallOption) (*UserInfo, error)
	// 获取用户列表
	ListUser(ctx context.Context, in *UserListRequest, opts ...grpc.CallOption) (*UserListResponse, error)
	// 获取用户 - 用户用户名
	GetUserByUsername(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*UserInfo, error)
	// TOTP相关接口
	// 启用TOTP - 生成密钥和二维码
	EnableTotp(ctx context.Context, in *EnableTotpRequest, opts ...grpc.CallOption) (*TotpSetupResponse, error)
	// 验证并确认TOTP设置
	VerifyTotpSetup(ctx context.Context, in *VerifyTotpSetupRequest, opts ...grpc.CallOption) (*TotpSetupConfirmResponse, error)
	// 禁用TOTP
	DisableTotp(ctx context.Context, in *DisableTotpRequest, opts ...grpc.CallOption) (*BaseResponse, error)
	// 验证TOTP代码（用于登录）
	VerifyTotpCode(ctx context.Context, in *VerifyTotpCodeRequest, opts ...grpc.CallOption) (*VerifyTotpCodeResponse, error)
	// 获取用户TOTP状态
	GetTotpStatus(ctx context.Context, in *UUIDRequest, opts ...grpc.CallOption) (*TotpStatusResponse, error)
	// 重新生成备用恢复码
	RegenerateBackupCodes(ctx context.Context, in *UUIDRequest, opts ...grpc.CallOption) (*BackupCodesResponse, error)
	// 使用备用恢复码
	UseBackupCode(ctx context.Context, in *UseBackupCodeRequest, opts ...grpc.CallOption) (*BaseResponse, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) CreateUser(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*UserInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserService_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUser(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*UserInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserService_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUser(ctx context.Context, in *UUIDRequest, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, UserService_DeleteUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUser(ctx context.Context, in *UUIDRequest, opts ...grpc.CallOption) (*UserInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserService_GetUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) ListUser(ctx context.Context, in *UserListRequest, opts ...grpc.CallOption) (*UserListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserListResponse)
	err := c.cc.Invoke(ctx, UserService_ListUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserByUsername(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*UserInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserService_GetUserByUsername_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) EnableTotp(ctx context.Context, in *EnableTotpRequest, opts ...grpc.CallOption) (*TotpSetupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TotpSetupResponse)
	err := c.cc.Invoke(ctx, UserService_EnableTotp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) VerifyTotpSetup(ctx context.Context, in *VerifyTotpSetupRequest, opts ...grpc.CallOption) (*TotpSetupConfirmResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TotpSetupConfirmResponse)
	err := c.cc.Invoke(ctx, UserService_VerifyTotpSetup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DisableTotp(ctx context.Context, in *DisableTotpRequest, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, UserService_DisableTotp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) VerifyTotpCode(ctx context.Context, in *VerifyTotpCodeRequest, opts ...grpc.CallOption) (*VerifyTotpCodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerifyTotpCodeResponse)
	err := c.cc.Invoke(ctx, UserService_VerifyTotpCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetTotpStatus(ctx context.Context, in *UUIDRequest, opts ...grpc.CallOption) (*TotpStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TotpStatusResponse)
	err := c.cc.Invoke(ctx, UserService_GetTotpStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) RegenerateBackupCodes(ctx context.Context, in *UUIDRequest, opts ...grpc.CallOption) (*BackupCodesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BackupCodesResponse)
	err := c.cc.Invoke(ctx, UserService_RegenerateBackupCodes_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UseBackupCode(ctx context.Context, in *UseBackupCodeRequest, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, UserService_UseBackupCode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	// 创建用户
	CreateUser(context.Context, *UserInfo) (*UserInfo, error)
	// 更新用户
	UpdateUser(context.Context, *UserInfo) (*UserInfo, error)
	// 删除用户
	DeleteUser(context.Context, *UUIDRequest) (*BaseResponse, error)
	// 获取用户
	GetUser(context.Context, *UUIDRequest) (*UserInfo, error)
	// 获取用户列表
	ListUser(context.Context, *UserListRequest) (*UserListResponse, error)
	// 获取用户 - 用户用户名
	GetUserByUsername(context.Context, *StringRequest) (*UserInfo, error)
	// TOTP相关接口
	// 启用TOTP - 生成密钥和二维码
	EnableTotp(context.Context, *EnableTotpRequest) (*TotpSetupResponse, error)
	// 验证并确认TOTP设置
	VerifyTotpSetup(context.Context, *VerifyTotpSetupRequest) (*TotpSetupConfirmResponse, error)
	// 禁用TOTP
	DisableTotp(context.Context, *DisableTotpRequest) (*BaseResponse, error)
	// 验证TOTP代码（用于登录）
	VerifyTotpCode(context.Context, *VerifyTotpCodeRequest) (*VerifyTotpCodeResponse, error)
	// 获取用户TOTP状态
	GetTotpStatus(context.Context, *UUIDRequest) (*TotpStatusResponse, error)
	// 重新生成备用恢复码
	RegenerateBackupCodes(context.Context, *UUIDRequest) (*BackupCodesResponse, error)
	// 使用备用恢复码
	UseBackupCode(context.Context, *UseBackupCodeRequest) (*BaseResponse, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) CreateUser(context.Context, *UserInfo) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedUserServiceServer) UpdateUser(context.Context, *UserInfo) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedUserServiceServer) DeleteUser(context.Context, *UUIDRequest) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUser not implemented")
}
func (UnimplementedUserServiceServer) GetUser(context.Context, *UUIDRequest) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUser not implemented")
}
func (UnimplementedUserServiceServer) ListUser(context.Context, *UserListRequest) (*UserListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUser not implemented")
}
func (UnimplementedUserServiceServer) GetUserByUsername(context.Context, *StringRequest) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserByUsername not implemented")
}
func (UnimplementedUserServiceServer) EnableTotp(context.Context, *EnableTotpRequest) (*TotpSetupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableTotp not implemented")
}
func (UnimplementedUserServiceServer) VerifyTotpSetup(context.Context, *VerifyTotpSetupRequest) (*TotpSetupConfirmResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyTotpSetup not implemented")
}
func (UnimplementedUserServiceServer) DisableTotp(context.Context, *DisableTotpRequest) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableTotp not implemented")
}
func (UnimplementedUserServiceServer) VerifyTotpCode(context.Context, *VerifyTotpCodeRequest) (*VerifyTotpCodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyTotpCode not implemented")
}
func (UnimplementedUserServiceServer) GetTotpStatus(context.Context, *UUIDRequest) (*TotpStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTotpStatus not implemented")
}
func (UnimplementedUserServiceServer) RegenerateBackupCodes(context.Context, *UUIDRequest) (*BackupCodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegenerateBackupCodes not implemented")
}
func (UnimplementedUserServiceServer) UseBackupCode(context.Context, *UseBackupCodeRequest) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UseBackupCode not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUser(ctx, req.(*UserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUser(ctx, req.(*UserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUser(ctx, req.(*UUIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUser(ctx, req.(*UUIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_ListUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).ListUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_ListUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).ListUser(ctx, req.(*UserListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserByUsername_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserByUsername(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserByUsername_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserByUsername(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_EnableTotp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableTotpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).EnableTotp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_EnableTotp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).EnableTotp(ctx, req.(*EnableTotpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_VerifyTotpSetup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyTotpSetupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).VerifyTotpSetup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_VerifyTotpSetup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).VerifyTotpSetup(ctx, req.(*VerifyTotpSetupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DisableTotp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableTotpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DisableTotp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DisableTotp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DisableTotp(ctx, req.(*DisableTotpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_VerifyTotpCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyTotpCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).VerifyTotpCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_VerifyTotpCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).VerifyTotpCode(ctx, req.(*VerifyTotpCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetTotpStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetTotpStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetTotpStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetTotpStatus(ctx, req.(*UUIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_RegenerateBackupCodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UUIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).RegenerateBackupCodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_RegenerateBackupCodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).RegenerateBackupCodes(ctx, req.(*UUIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UseBackupCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UseBackupCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UseBackupCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UseBackupCode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UseBackupCode(ctx, req.(*UseBackupCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UserService_CreateUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _UserService_UpdateUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UserService_DeleteUser_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _UserService_GetUser_Handler,
		},
		{
			MethodName: "ListUser",
			Handler:    _UserService_ListUser_Handler,
		},
		{
			MethodName: "GetUserByUsername",
			Handler:    _UserService_GetUserByUsername_Handler,
		},
		{
			MethodName: "EnableTotp",
			Handler:    _UserService_EnableTotp_Handler,
		},
		{
			MethodName: "VerifyTotpSetup",
			Handler:    _UserService_VerifyTotpSetup_Handler,
		},
		{
			MethodName: "DisableTotp",
			Handler:    _UserService_DisableTotp_Handler,
		},
		{
			MethodName: "VerifyTotpCode",
			Handler:    _UserService_VerifyTotpCode_Handler,
		},
		{
			MethodName: "GetTotpStatus",
			Handler:    _UserService_GetTotpStatus_Handler,
		},
		{
			MethodName: "RegenerateBackupCodes",
			Handler:    _UserService_RegenerateBackupCodes_Handler,
		},
		{
			MethodName: "UseBackupCode",
			Handler:    _UserService_UseBackupCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/core.proto",
}

const (
	OauthProviderService_CreateOrUpdateOauthProvider_FullMethodName = "/core.OauthProviderService/CreateOrUpdateOauthProvider"
	OauthProviderService_DeleteOauthProvider_FullMethodName         = "/core.OauthProviderService/DeleteOauthProvider"
	OauthProviderService_GetOauthProvider_FullMethodName            = "/core.OauthProviderService/GetOauthProvider"
	OauthProviderService_ListOauthProvider_FullMethodName           = "/core.OauthProviderService/ListOauthProvider"
	OauthProviderService_OauthLogin_FullMethodName                  = "/core.OauthProviderService/OauthLogin"
	OauthProviderService_OauthCallback_FullMethodName               = "/core.OauthProviderService/OauthCallback"
)

// OauthProviderServiceClient is the client API for OauthProviderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OauthProviderServiceClient interface {
	// 创建或更新提供商
	CreateOrUpdateOauthProvider(ctx context.Context, in *OauthProviderInfo, opts ...grpc.CallOption) (*OauthProviderInfo, error)
	// 删除提供商
	DeleteOauthProvider(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error)
	// 获取提供商
	GetOauthProvider(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*OauthProviderInfo, error)
	// 获取提供商列表
	ListOauthProvider(ctx context.Context, in *OauthProviderListRequest, opts ...grpc.CallOption) (*OauthProviderListResponse, error)
	// Oauth Login
	OauthLogin(ctx context.Context, in *OauthLoginRequest, opts ...grpc.CallOption) (*OauthRedirectResponse, error)
	// Oauth Callback
	OauthCallback(ctx context.Context, in *OauthCallbackRequest, opts ...grpc.CallOption) (*UserInfo, error)
}

type oauthProviderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewOauthProviderServiceClient(cc grpc.ClientConnInterface) OauthProviderServiceClient {
	return &oauthProviderServiceClient{cc}
}

func (c *oauthProviderServiceClient) CreateOrUpdateOauthProvider(ctx context.Context, in *OauthProviderInfo, opts ...grpc.CallOption) (*OauthProviderInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OauthProviderInfo)
	err := c.cc.Invoke(ctx, OauthProviderService_CreateOrUpdateOauthProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oauthProviderServiceClient) DeleteOauthProvider(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, OauthProviderService_DeleteOauthProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oauthProviderServiceClient) GetOauthProvider(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*OauthProviderInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OauthProviderInfo)
	err := c.cc.Invoke(ctx, OauthProviderService_GetOauthProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oauthProviderServiceClient) ListOauthProvider(ctx context.Context, in *OauthProviderListRequest, opts ...grpc.CallOption) (*OauthProviderListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OauthProviderListResponse)
	err := c.cc.Invoke(ctx, OauthProviderService_ListOauthProvider_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oauthProviderServiceClient) OauthLogin(ctx context.Context, in *OauthLoginRequest, opts ...grpc.CallOption) (*OauthRedirectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(OauthRedirectResponse)
	err := c.cc.Invoke(ctx, OauthProviderService_OauthLogin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oauthProviderServiceClient) OauthCallback(ctx context.Context, in *OauthCallbackRequest, opts ...grpc.CallOption) (*UserInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, OauthProviderService_OauthCallback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OauthProviderServiceServer is the server API for OauthProviderService service.
// All implementations must embed UnimplementedOauthProviderServiceServer
// for forward compatibility
type OauthProviderServiceServer interface {
	// 创建或更新提供商
	CreateOrUpdateOauthProvider(context.Context, *OauthProviderInfo) (*OauthProviderInfo, error)
	// 删除提供商
	DeleteOauthProvider(context.Context, *ID32Request) (*BaseResponse, error)
	// 获取提供商
	GetOauthProvider(context.Context, *ID32Request) (*OauthProviderInfo, error)
	// 获取提供商列表
	ListOauthProvider(context.Context, *OauthProviderListRequest) (*OauthProviderListResponse, error)
	// Oauth Login
	OauthLogin(context.Context, *OauthLoginRequest) (*OauthRedirectResponse, error)
	// Oauth Callback
	OauthCallback(context.Context, *OauthCallbackRequest) (*UserInfo, error)
	mustEmbedUnimplementedOauthProviderServiceServer()
}

// UnimplementedOauthProviderServiceServer must be embedded to have forward compatible implementations.
type UnimplementedOauthProviderServiceServer struct {
}

func (UnimplementedOauthProviderServiceServer) CreateOrUpdateOauthProvider(context.Context, *OauthProviderInfo) (*OauthProviderInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrUpdateOauthProvider not implemented")
}
func (UnimplementedOauthProviderServiceServer) DeleteOauthProvider(context.Context, *ID32Request) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteOauthProvider not implemented")
}
func (UnimplementedOauthProviderServiceServer) GetOauthProvider(context.Context, *ID32Request) (*OauthProviderInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOauthProvider not implemented")
}
func (UnimplementedOauthProviderServiceServer) ListOauthProvider(context.Context, *OauthProviderListRequest) (*OauthProviderListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOauthProvider not implemented")
}
func (UnimplementedOauthProviderServiceServer) OauthLogin(context.Context, *OauthLoginRequest) (*OauthRedirectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OauthLogin not implemented")
}
func (UnimplementedOauthProviderServiceServer) OauthCallback(context.Context, *OauthCallbackRequest) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OauthCallback not implemented")
}
func (UnimplementedOauthProviderServiceServer) mustEmbedUnimplementedOauthProviderServiceServer() {}

// UnsafeOauthProviderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OauthProviderServiceServer will
// result in compilation errors.
type UnsafeOauthProviderServiceServer interface {
	mustEmbedUnimplementedOauthProviderServiceServer()
}

func RegisterOauthProviderServiceServer(s grpc.ServiceRegistrar, srv OauthProviderServiceServer) {
	s.RegisterService(&OauthProviderService_ServiceDesc, srv)
}

func _OauthProviderService_CreateOrUpdateOauthProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OauthProviderInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OauthProviderServiceServer).CreateOrUpdateOauthProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OauthProviderService_CreateOrUpdateOauthProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OauthProviderServiceServer).CreateOrUpdateOauthProvider(ctx, req.(*OauthProviderInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _OauthProviderService_DeleteOauthProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OauthProviderServiceServer).DeleteOauthProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OauthProviderService_DeleteOauthProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OauthProviderServiceServer).DeleteOauthProvider(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _OauthProviderService_GetOauthProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OauthProviderServiceServer).GetOauthProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OauthProviderService_GetOauthProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OauthProviderServiceServer).GetOauthProvider(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _OauthProviderService_ListOauthProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OauthProviderListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OauthProviderServiceServer).ListOauthProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OauthProviderService_ListOauthProvider_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OauthProviderServiceServer).ListOauthProvider(ctx, req.(*OauthProviderListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OauthProviderService_OauthLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OauthLoginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OauthProviderServiceServer).OauthLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OauthProviderService_OauthLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OauthProviderServiceServer).OauthLogin(ctx, req.(*OauthLoginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OauthProviderService_OauthCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OauthCallbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OauthProviderServiceServer).OauthCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OauthProviderService_OauthCallback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OauthProviderServiceServer).OauthCallback(ctx, req.(*OauthCallbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OauthProviderService_ServiceDesc is the grpc.ServiceDesc for OauthProviderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OauthProviderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.OauthProviderService",
	HandlerType: (*OauthProviderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateOrUpdateOauthProvider",
			Handler:    _OauthProviderService_CreateOrUpdateOauthProvider_Handler,
		},
		{
			MethodName: "DeleteOauthProvider",
			Handler:    _OauthProviderService_DeleteOauthProvider_Handler,
		},
		{
			MethodName: "GetOauthProvider",
			Handler:    _OauthProviderService_GetOauthProvider_Handler,
		},
		{
			MethodName: "ListOauthProvider",
			Handler:    _OauthProviderService_ListOauthProvider_Handler,
		},
		{
			MethodName: "OauthLogin",
			Handler:    _OauthProviderService_OauthLogin_Handler,
		},
		{
			MethodName: "OauthCallback",
			Handler:    _OauthProviderService_OauthCallback_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/core.proto",
}

const (
	TokenService_CreateToken_FullMethodName            = "/core.TokenService/CreateToken"
	TokenService_GetToken_FullMethodName               = "/core.TokenService/GetToken"
	TokenService_GetTokenByValue_FullMethodName        = "/core.TokenService/GetTokenByValue"
	TokenService_ValidateToken_FullMethodName          = "/core.TokenService/ValidateToken"
	TokenService_UpdateToken_FullMethodName            = "/core.TokenService/UpdateToken"
	TokenService_DeleteToken_FullMethodName            = "/core.TokenService/DeleteToken"
	TokenService_RevokeToken_FullMethodName            = "/core.TokenService/RevokeToken"
	TokenService_RevokeUserTokens_FullMethodName       = "/core.TokenService/RevokeUserTokens"
	TokenService_ListToken_FullMethodName              = "/core.TokenService/ListToken"
	TokenService_CleanExpiredTokens_FullMethodName     = "/core.TokenService/CleanExpiredTokens"
	TokenService_UpdateTokenLastUsed_FullMethodName    = "/core.TokenService/UpdateTokenLastUsed"
	TokenService_GetTokenByRefreshToken_FullMethodName = "/core.TokenService/GetTokenByRefreshToken"
)

// TokenServiceClient is the client API for TokenService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Token服务
type TokenServiceClient interface {
	// 创建Token
	CreateToken(ctx context.Context, in *CreateTokenRequest, opts ...grpc.CallOption) (*TokenInfo, error)
	// 获取Token
	GetToken(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*TokenInfo, error)
	// 根据Token值获取Token信息
	GetTokenByValue(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*TokenInfo, error)
	// 验证Token
	ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error)
	// 更新Token
	UpdateToken(ctx context.Context, in *TokenInfo, opts ...grpc.CallOption) (*TokenInfo, error)
	// 删除Token
	DeleteToken(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error)
	// 撤销Token
	RevokeToken(ctx context.Context, in *RevokeTokenRequest, opts ...grpc.CallOption) (*BaseResponse, error)
	// 撤销用户的所有Token（除了blockUserAllToken功能）
	RevokeUserTokens(ctx context.Context, in *RevokeUserTokensRequest, opts ...grpc.CallOption) (*BaseResponse, error)
	// 获取Token列表
	ListToken(ctx context.Context, in *TokenListRequest, opts ...grpc.CallOption) (*TokenListResponse, error)
	// 清理过期Token
	CleanExpiredTokens(ctx context.Context, in *CleanExpiredTokensRequest, opts ...grpc.CallOption) (*CleanExpiredTokensResponse, error)
	// 更新Token最后使用时间
	UpdateTokenLastUsed(ctx context.Context, in *UpdateTokenLastUsedRequest, opts ...grpc.CallOption) (*BaseResponse, error)
	// 根据刷新Token ID获取相关的访问Token
	GetTokenByRefreshToken(ctx context.Context, in *GetTokenByRefreshTokenRequest, opts ...grpc.CallOption) (*TokenInfo, error)
}

type tokenServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTokenServiceClient(cc grpc.ClientConnInterface) TokenServiceClient {
	return &tokenServiceClient{cc}
}

func (c *tokenServiceClient) CreateToken(ctx context.Context, in *CreateTokenRequest, opts ...grpc.CallOption) (*TokenInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenInfo)
	err := c.cc.Invoke(ctx, TokenService_CreateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) GetToken(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*TokenInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenInfo)
	err := c.cc.Invoke(ctx, TokenService_GetToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) GetTokenByValue(ctx context.Context, in *StringRequest, opts ...grpc.CallOption) (*TokenInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenInfo)
	err := c.cc.Invoke(ctx, TokenService_GetTokenByValue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) ValidateToken(ctx context.Context, in *ValidateTokenRequest, opts ...grpc.CallOption) (*ValidateTokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateTokenResponse)
	err := c.cc.Invoke(ctx, TokenService_ValidateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) UpdateToken(ctx context.Context, in *TokenInfo, opts ...grpc.CallOption) (*TokenInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenInfo)
	err := c.cc.Invoke(ctx, TokenService_UpdateToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) DeleteToken(ctx context.Context, in *ID32Request, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, TokenService_DeleteToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) RevokeToken(ctx context.Context, in *RevokeTokenRequest, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, TokenService_RevokeToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) RevokeUserTokens(ctx context.Context, in *RevokeUserTokensRequest, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, TokenService_RevokeUserTokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) ListToken(ctx context.Context, in *TokenListRequest, opts ...grpc.CallOption) (*TokenListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenListResponse)
	err := c.cc.Invoke(ctx, TokenService_ListToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) CleanExpiredTokens(ctx context.Context, in *CleanExpiredTokensRequest, opts ...grpc.CallOption) (*CleanExpiredTokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CleanExpiredTokensResponse)
	err := c.cc.Invoke(ctx, TokenService_CleanExpiredTokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) UpdateTokenLastUsed(ctx context.Context, in *UpdateTokenLastUsedRequest, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, TokenService_UpdateTokenLastUsed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tokenServiceClient) GetTokenByRefreshToken(ctx context.Context, in *GetTokenByRefreshTokenRequest, opts ...grpc.CallOption) (*TokenInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TokenInfo)
	err := c.cc.Invoke(ctx, TokenService_GetTokenByRefreshToken_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TokenServiceServer is the server API for TokenService service.
// All implementations must embed UnimplementedTokenServiceServer
// for forward compatibility
//
// Token服务
type TokenServiceServer interface {
	// 创建Token
	CreateToken(context.Context, *CreateTokenRequest) (*TokenInfo, error)
	// 获取Token
	GetToken(context.Context, *ID32Request) (*TokenInfo, error)
	// 根据Token值获取Token信息
	GetTokenByValue(context.Context, *StringRequest) (*TokenInfo, error)
	// 验证Token
	ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error)
	// 更新Token
	UpdateToken(context.Context, *TokenInfo) (*TokenInfo, error)
	// 删除Token
	DeleteToken(context.Context, *ID32Request) (*BaseResponse, error)
	// 撤销Token
	RevokeToken(context.Context, *RevokeTokenRequest) (*BaseResponse, error)
	// 撤销用户的所有Token（除了blockUserAllToken功能）
	RevokeUserTokens(context.Context, *RevokeUserTokensRequest) (*BaseResponse, error)
	// 获取Token列表
	ListToken(context.Context, *TokenListRequest) (*TokenListResponse, error)
	// 清理过期Token
	CleanExpiredTokens(context.Context, *CleanExpiredTokensRequest) (*CleanExpiredTokensResponse, error)
	// 更新Token最后使用时间
	UpdateTokenLastUsed(context.Context, *UpdateTokenLastUsedRequest) (*BaseResponse, error)
	// 根据刷新Token ID获取相关的访问Token
	GetTokenByRefreshToken(context.Context, *GetTokenByRefreshTokenRequest) (*TokenInfo, error)
	mustEmbedUnimplementedTokenServiceServer()
}

// UnimplementedTokenServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTokenServiceServer struct {
}

func (UnimplementedTokenServiceServer) CreateToken(context.Context, *CreateTokenRequest) (*TokenInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateToken not implemented")
}
func (UnimplementedTokenServiceServer) GetToken(context.Context, *ID32Request) (*TokenInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetToken not implemented")
}
func (UnimplementedTokenServiceServer) GetTokenByValue(context.Context, *StringRequest) (*TokenInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenByValue not implemented")
}
func (UnimplementedTokenServiceServer) ValidateToken(context.Context, *ValidateTokenRequest) (*ValidateTokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateToken not implemented")
}
func (UnimplementedTokenServiceServer) UpdateToken(context.Context, *TokenInfo) (*TokenInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateToken not implemented")
}
func (UnimplementedTokenServiceServer) DeleteToken(context.Context, *ID32Request) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteToken not implemented")
}
func (UnimplementedTokenServiceServer) RevokeToken(context.Context, *RevokeTokenRequest) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeToken not implemented")
}
func (UnimplementedTokenServiceServer) RevokeUserTokens(context.Context, *RevokeUserTokensRequest) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeUserTokens not implemented")
}
func (UnimplementedTokenServiceServer) ListToken(context.Context, *TokenListRequest) (*TokenListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListToken not implemented")
}
func (UnimplementedTokenServiceServer) CleanExpiredTokens(context.Context, *CleanExpiredTokensRequest) (*CleanExpiredTokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CleanExpiredTokens not implemented")
}
func (UnimplementedTokenServiceServer) UpdateTokenLastUsed(context.Context, *UpdateTokenLastUsedRequest) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTokenLastUsed not implemented")
}
func (UnimplementedTokenServiceServer) GetTokenByRefreshToken(context.Context, *GetTokenByRefreshTokenRequest) (*TokenInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTokenByRefreshToken not implemented")
}
func (UnimplementedTokenServiceServer) mustEmbedUnimplementedTokenServiceServer() {}

// UnsafeTokenServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TokenServiceServer will
// result in compilation errors.
type UnsafeTokenServiceServer interface {
	mustEmbedUnimplementedTokenServiceServer()
}

func RegisterTokenServiceServer(s grpc.ServiceRegistrar, srv TokenServiceServer) {
	s.RegisterService(&TokenService_ServiceDesc, srv)
}

func _TokenService_CreateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).CreateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_CreateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).CreateToken(ctx, req.(*CreateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_GetToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).GetToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_GetToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).GetToken(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_GetTokenByValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).GetTokenByValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_GetTokenByValue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).GetTokenByValue(ctx, req.(*StringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_ValidateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).ValidateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_ValidateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).ValidateToken(ctx, req.(*ValidateTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_UpdateToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).UpdateToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_UpdateToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).UpdateToken(ctx, req.(*TokenInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_DeleteToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ID32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).DeleteToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_DeleteToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).DeleteToken(ctx, req.(*ID32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_RevokeToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).RevokeToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_RevokeToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).RevokeToken(ctx, req.(*RevokeTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_RevokeUserTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RevokeUserTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).RevokeUserTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_RevokeUserTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).RevokeUserTokens(ctx, req.(*RevokeUserTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_ListToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TokenListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).ListToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_ListToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).ListToken(ctx, req.(*TokenListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_CleanExpiredTokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanExpiredTokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).CleanExpiredTokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_CleanExpiredTokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).CleanExpiredTokens(ctx, req.(*CleanExpiredTokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_UpdateTokenLastUsed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTokenLastUsedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).UpdateTokenLastUsed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_UpdateTokenLastUsed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).UpdateTokenLastUsed(ctx, req.(*UpdateTokenLastUsedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TokenService_GetTokenByRefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTokenByRefreshTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TokenServiceServer).GetTokenByRefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TokenService_GetTokenByRefreshToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TokenServiceServer).GetTokenByRefreshToken(ctx, req.(*GetTokenByRefreshTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TokenService_ServiceDesc is the grpc.ServiceDesc for TokenService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TokenService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.TokenService",
	HandlerType: (*TokenServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateToken",
			Handler:    _TokenService_CreateToken_Handler,
		},
		{
			MethodName: "GetToken",
			Handler:    _TokenService_GetToken_Handler,
		},
		{
			MethodName: "GetTokenByValue",
			Handler:    _TokenService_GetTokenByValue_Handler,
		},
		{
			MethodName: "ValidateToken",
			Handler:    _TokenService_ValidateToken_Handler,
		},
		{
			MethodName: "UpdateToken",
			Handler:    _TokenService_UpdateToken_Handler,
		},
		{
			MethodName: "DeleteToken",
			Handler:    _TokenService_DeleteToken_Handler,
		},
		{
			MethodName: "RevokeToken",
			Handler:    _TokenService_RevokeToken_Handler,
		},
		{
			MethodName: "RevokeUserTokens",
			Handler:    _TokenService_RevokeUserTokens_Handler,
		},
		{
			MethodName: "ListToken",
			Handler:    _TokenService_ListToken_Handler,
		},
		{
			MethodName: "CleanExpiredTokens",
			Handler:    _TokenService_CleanExpiredTokens_Handler,
		},
		{
			MethodName: "UpdateTokenLastUsed",
			Handler:    _TokenService_UpdateTokenLastUsed_Handler,
		},
		{
			MethodName: "GetTokenByRefreshToken",
			Handler:    _TokenService_GetTokenByRefreshToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/core.proto",
}

const (
	InitService_Init_FullMethodName = "/core.InitService/Init"
)

// InitServiceClient is the client API for InitService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// 初始化服务
type InitServiceClient interface {
	Init(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*BaseResponse, error)
}

type initServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInitServiceClient(cc grpc.ClientConnInterface) InitServiceClient {
	return &initServiceClient{cc}
}

func (c *initServiceClient) Init(ctx context.Context, in *EmptyRequest, opts ...grpc.CallOption) (*BaseResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(BaseResponse)
	err := c.cc.Invoke(ctx, InitService_Init_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InitServiceServer is the server API for InitService service.
// All implementations must embed UnimplementedInitServiceServer
// for forward compatibility
//
// 初始化服务
type InitServiceServer interface {
	Init(context.Context, *EmptyRequest) (*BaseResponse, error)
	mustEmbedUnimplementedInitServiceServer()
}

// UnimplementedInitServiceServer must be embedded to have forward compatible implementations.
type UnimplementedInitServiceServer struct {
}

func (UnimplementedInitServiceServer) Init(context.Context, *EmptyRequest) (*BaseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Init not implemented")
}
func (UnimplementedInitServiceServer) mustEmbedUnimplementedInitServiceServer() {}

// UnsafeInitServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InitServiceServer will
// result in compilation errors.
type UnsafeInitServiceServer interface {
	mustEmbedUnimplementedInitServiceServer()
}

func RegisterInitServiceServer(s grpc.ServiceRegistrar, srv InitServiceServer) {
	s.RegisterService(&InitService_ServiceDesc, srv)
}

func _InitService_Init_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EmptyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InitServiceServer).Init(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InitService_Init_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InitServiceServer).Init(ctx, req.(*EmptyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InitService_ServiceDesc is the grpc.ServiceDesc for InitService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InitService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "core.InitService",
	HandlerType: (*InitServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Init",
			Handler:    _InitService_Init_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/core.proto",
}
